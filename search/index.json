[{"content":" 此文档使用VSCode+Vim模拟插件进行编写\n启程 闲来无事，突然想学Vim了。直到现在也只会基本操作，惨\n参考文献：\n《学习vi与Vim编辑器 8th Edition》 Vim三大模式介绍 Vim分为三个模式：普通模式、插入模式、ex模式\n普通模式\n当按键用于执行命令时的模式，一开始进Vim时就是普通模式，通过按Esc进入。请注意，vi与Vim在普通模式时指令区分大小写\n普通模式又称命令模式，即按键只处理命令，不直接插入到文本\n插入模式\n通过按i键进入，插入模式允许用户直接在光标处编辑文本，就像notepad一样\nex模式\n在普通模式通过输入:进入，ex模式允许用户输入ex指令完成单行或跨行编辑，同样区分大小写。\nex命令是ex行编辑器使用的指令，ex行编辑器是古早Unix系统使用的单行终端编辑器，属于Linux底层编辑器\n一般来说，普通模式用于快速翻阅代码或快捷更改字符或删除行等，插入模式用于普通编辑文本，ex模式则用于搜索全文，或使用高级指令完成编辑操作等。\n打开文件 一句话：vim [filename]\n当然，有可能你需要先安装vim（笑）\n操作模式 第一次使用Vim时，你是否也曾敲打键盘，却没有任何字符输入？甚至莫名其妙把内容删除了？\n普通模式是这样的，当进入Vim时，默认会进入普通模式，此时键盘上每个按键都代表一个指令，而非代表内容的文本。\n请注意，并非所有按键都有对应的命令，而是说在普通模式中，Vim认为接收到的按键代表的是“命令”。\n此时，若想输入文本，请确保在小写状态下，按下i键，进入插入模式，此时再键入的就是文本本身了。\n保存，或者直接退出 恭喜你，终于用Vim成功写了一点东西，也许是代码，也许是随便乱打的，那么来到了第二个问题：我该怎么退出这沟槽的Vim？\n保存退出\n在普通模式下，按下Shift+zz，也就是输入两个大写的Z，这个是保存并退出指令，在一切顺利的情况下，Vim会将缓存区中的文本写入文件，并退出程序。\n不知道现在是什么模式？多按几下Esc，就一定处于命令模式！\n强制退出\n有时候，因为某些原因（虽然大多数是只读问题），Vim无法保存文件，并且会提示包括[Read only]的信息。\n别慌，Vim可以通过ex指令实现强制退出。\n还记得怎么进入ex模式吗？按下Shift+；，也就是输入:，此时你会看到终端最下面出现了:，这代表着你成功进入了ex模式。\n紧接着，输入q!，按下Enter，成功退出！并且不会保存任何文件。\n!在ex模式中代表强制，刚才的指令就是强制退出的意思。一般来说，如果没有修改任何文件的话，输入q就可以了。\n当然，ex指令下也可以保存退出，只需要输入:wq并回车就可以了。具体指令会在后面详解。\n同时，从现在开始，将不再重复强调如何进入某种模式，也不再强调ex模式下需要用回车来执行指令。\n另存为\nex模式下输入w [filename]，即可另存为新文件。 当然，输入w! [filename]会将内容覆盖到已存在的文件中，无法撤回！\n使用!时还请三思。\n简单（？）的文本编辑 一般来说，学习上面内容后，就可以使用Vim简单进行编辑了，不过，在面对几千行的代码时，若是用方向键+插入去修改的话，我猜你肯定很想砸键盘。\n这部分内容主要讲述如何在上文基础上，使用简单易学的操作提高一些编辑的效率，让你砸键盘的欲望变得小一点。\nvi命令 复习：上文中，Vim有几种模式？都以什么方式进入？\nTips：可以将不同的模式想像成不同的键盘，在插入模式中，键盘功能就像平常一样。在普通模式中，每个键都有新的含义或是代表某种动作。\n在你按Esc之前，插入命令之后的所有按键输入都被视为文本。\n移动光标 在进行编辑工作（看代码）的时候，更多的时候都是在文件中四处移动，使用各种命令编辑现有文本。\n本节首先讲述最基本的光标移动操作\n按上下左右四个方向将光标一次移动一个字符位置 按照文本块（单词、句子或段落）向前或向后移动光标 在文件中以屏为单位移动光标 单一移动 虽然Vim支持方向键移动光标，但是更常用h、j、k、l进行光标移动。\nh\n向左移动一个位置\nj\n移动到下一行\nk\n移动到上一行\nl\n向右移动一个字符位置\n这种移动方式的好处是：你的手指可以在不离开键盘中心区域的情况下四处移动光标。\n当然，移动光标前，请确保你在命令模式下使用。\n数量级参数 在命令前输入数字，此时这个数字被称为重复计数（repeat count）或复制因子（replication factor）\n现在，在Vim试一下4l吧，你会发现，光标向右移动了四个位置，也就相当于你一次输入了4个l。\n当然，数字的输入要在命令之前，否则Vim永远也不知道数字的输入何时结束。\n行内移动 移动到行首：0（数字0）\n移动到行尾：$\n这里的行指的是文件中实际的一行，可以通过ex命令输入set nu查看文件行号。\n也就是说，使用行首行尾移动时，有可能在屏幕中显示为跳转多个行，但实际上光标只在一行文本中移动。\n按文本块移动 请注意大小写\n此处的文本块仅指单词，后续部分会介绍按句子，按段落等。\nw：光标向右移动一个单词（由字母数字字符组成）\n请注意，此时单个符号和标点也视为一个单词。\nW：光标向右移动一个用空格分割的段\nw会跳转到下一个符号或空格后第一个字符处，而W仅会跳转到下一个空格后第一个字符处。\nb：光标向左移动一个单词\nB：光标向左移动一个用空格分割的段\nG：光标跳转到指定的行\n单独的G会跳转到文件末尾，在G前面添加数量参数时，会跳转到文件指定的行，如42G会跳转到文件42行。\n以上的指令都可以加入数量参数，如2W会让光标向右移动两个用空格分割的段。\n修改文本 插入新文本 前面说过，i键会进入插入模式。\n当按下i键时，请注意，此时插入光标（小竖线）是在光标（在字符闪烁的小块）的左边的，万分注意。\n追加文本 追加文本，顾名思义，就是将插入光标放置在光标右边，随后进入插入模式。\n某种意义上，a键也是进入插入模式的一种方式。\n更改文本 c键为更改命令，需要指定范围，一般与移动命令结合使用。\n一旦生效，更改命令会删除指定范围字符，并且自动进入插入模式。\n还记得上面的移动指令吗？\n例如：c可用于更改从光标位置开始的文本：\ncw：从光标位置到单词结尾 c2b：从光标位置向左两个单词 c$：从光标位置到行尾 c0：从光标位置到行首 与i和a一样，在按Esc之前，你一直都处于插入模式。\ncw指令取决于光标位置，若是光标在单词中间，则只会更改单词中间到结尾的字符。\n整行更改 使用cc对整行文本进行更改，无论光标处于该行何种位置，cc都会替换掉整行文本。\n使用C或c$来替换从当前光标位置到行尾的所有字符。\n无论是cc还是C，都不用在指令末尾指定文字对象，但是可以在指令前面添加数量参数。\n字符更改 r是另一个用于替换文本的命令，该命令使用一个字符替换另一个字符，且无需按Esc就可以返回命令模式。\n格式：[数量参数] r [要替换成的字符]\n注意：数量参数会让后面多个字符替换成同一个字符。\ns与r的作用与命令格式相同，不同的是，使用s更改后，会进入到插入模式。\nS命令可以替换整行文本，且不同于C命令，S命令会删除整行，之后进入插入模式，光标置于行首。\n在前面加上数量参数，可以实现多行删除并进入到插入模式。\nR命令比较特殊，不同于r，该命令会直接进入改写模式，此时键盘输入的字符会直接逐个替换屏幕上的文本，直到按下Esc。并且，当删除替换字符时，原先字符会恢复。\n当按下Enter时，编辑器会插入新行。\n更改大小写（英文） ~可以对光标所处字符更改大小写。同样，输入数量参数可以对多个字符更改。\n若想更改多行，只能使用Unix指令，后面会讲解。\n删除文本 删除命令d可用于删除文件中的任意文本。和更改命令一样，删除命令也需要文本对象。\n无论哪种形式的删除命令，都要先将光标移动到待删除文本的起始位置，然后输入删除命令d和文本对象。\n其实，文本对象指的就是像w，2w一类的东西，也可以是l，2l这种移动指令，这会向后删除两个字符。\n单词 dw删除从光标所在位置开始的第一个单词。注意，单词之后的空格也会被一并删除。\n若想保留单词之后的空格，可以使用de而不是dw。若想连带后面标点符号也删除，请使用dE。\ne指令为到达下一个单词末尾，而E则移动到下一个空格分隔的单词尾部。\n行 dd：删除整个行\nD：从光标开始删除到末尾（等同于d$）\n字符 往往，可能仅仅只是删除某个字符，却不需要修改。\nx命令仅删除光标所在的字符，同样，也可以加入数量参数，删除光标及之后的更多字符。\nX命令则会删除光标之前的字符，支持数量参数。\n二者使用后都会保持命令模式不变。\n撤回 u可以撤回上一次的操作（如dd）（Undo）\nU可以恢复一整行文本到原先状态\nCtrl+r可以恢复上一次的撤回操作（Redo）\n.可以重复上一次的指令\n请注意，以上操作仅限于在命令模式中删除（像x、dd）的情况，在插入模式中删除时，仅靠u并不能实现，保持插入模式之后Ctrl+Z就可以了。\n移动文本 每次删除一个文本块，被删除的内容就会被保存在一个特殊的无名区域，称为删除寄存器。\n那么，在Vim中，剪切文本的操作就是删除-\u0026gt;选取位置-\u0026gt;用放置命令p这样的流程实现的。\n","date":"2025-08-04T00:00:00Z","permalink":"https://deathofbrain.github.io/p/vim/","title":"Vim之旅"},{"content":"计算机网络体系结构 本章内容重点：三种交换（计算）、OSI分层、TCP/IP分层（记忆）、各种指标与单位（计算）\n▲计算机网络概述 ▲概念 定义：将地理位置不同，具有独立功能的多台计算机以及外部设备通过通信线路连接起来，实现资源共享和信息传递的操作系统。\n组成 需要知道哪些东西是哪个部分的就可以了\n从组成部分看，计算机网络主要由硬件、软件、协议三大部分组成。 硬件：由主机、通信链路、交换设备和网卡等组成 软件：包括email程序、ftp程序等 协议：计算机网络的核心，规定了网络传输数据时所遵循的规范。 从工作方式看，可分为边缘部分和核心部分 边缘部分：由所有连接到互联网上的供用户直接使用的主机构成，进行通信和资源共享。 核心部分：大量网络和连接着的路由器组成。 从功能组成看，可分为通信子网和资源子网。 通信子网：各种传输介质、通信设备和相应网络协议组成。 使网络具有数据传输、交换、控制和存储的能力，实现数据通信。 资源子网：实现资源共享的设备及其软件的集合 向网络用户提供共享其他计算机上的硬件资源、软件资源、数据资源的服务。 功能 数据通信：最基本和最重要的功能，实现联网计算机之间信息的传输。 资源共享：共享软件、硬件、数据，让网络中资源互通有无。 分布式处理：将某个复杂的任务分配给网络中其它计算机系统，提高整个系统的利用率。 提高可靠性：网络中的各台计算机可以互为替代机。 负载均衡：将工作任务均衡地分配给网络中各台计算机。 🌟电路交换、报文交换和分组交换 计网计算题重点，可结合到多种题型\n路由器这个网络层设备在网络核心部分起到重要作用。它对收到的分组进行存储转发实现分组交换。分组交换是现代网络最常用的交换方式。\n从通信资源分配的角度看，交换就是按照某种方式动态地分配传输线路的资源。\n分组交换由电路交换与报文交换发展而来。\n电路交换（典型：电话网） 特点：在进行数据传输前，两个用户之间必须先建立一条专用的物理通信路径，且传输过程中，这一路径始终被两个用户独占，直到通信结束被释放。\n分为三步：建立连接（开始占用通信资源）、传输数据、释放连接。\n示意图：\n整条电路上任何节点都不进行存储，直接转发，不存在存储转发所耗费的时间。\n这一点需要记住。\n优点：通信时延小、有序传输、没有冲突、实时性强。\n缺点：建立连接时间长、线路利用率低、灵活性差、难以实现差错控制。\n灵活性差：物理通路中，任何一点出现故障，就必须重新建立连接。\n难以实现差错控制：中间节点不具备存储和检验数据的能力，无法发现并纠正错误。\n事实上，计算机之间的数据传输往往是突发式的（高频、少量数据），若使用电路交换，那么整个通信链路资源的利用率往往不到10%，甚至只有1%。\n报文交换——分组交换的前身\n数据交换的单位是报文。报文由用户数据、源地址和目的地址等信息组成。\n采用存储转发技术，整个报文先传送到相邻的节点，全部存储后查找转发表，转发到下一个节点，如此反复，直到报文到达目的节点。\n全部存储——报文交换被淘汰的原因\n不同于电路交换，每个报文都可单独选择到达目的端的路径。示例图如下：\n优点：无建立连接时延、灵活分配线路、线路利用率高、支持差错控制。\n这些也是存储转发本身的优点。\n缺点：转发时延高、缓存开销大、错误处理低效。\n交换节点要把报文都存储完才能查找转发表转发到下一节点，若是报文太大，缓存开销也大，并且一旦丢包，重传代价也大。\n分组交换，就是在报文交换存储转发的基础上，将报文划分成若干较小等长数据段，每个数据段前面添加一些由控制信息组成的首部，构成分组（Packet）。\n分组交换\n流程\n源主机发送分组，分组交换网中的交换机收到分组后，先缓存，然后从首部提取目的地址，借由转发表，发送给下一个交换机，周而复始，直到到达目的主机。\n本质上和报文交换一样\n优点：存储转发开销小、传输效率高、减少出错概率与代价。\n分组是逐个传输的，可以使后一个分组的存储操作与前一个分组的转发操作并行，形成流水线，后面的图会详细表达。\n缺点：存在存储转发时延、需要传输额外信息、可能出现失序、丢失或重复分组的情况。\n失序丢包等问题是借由上层，或使用虚电路服务解决的，先不必深究。\n三种交换方式的比较\n当要连续传输大量的数据，并且传送时间远大于连接建立时间时，采用电路交换更合适。\n然而，现时代，数据的传送时间肯定小于连接建立时间。\n从提高整个网络的信道利用率看，报文交换和分组交换更合适\n其中，分组交换比报文交换时延更小，更加灵活，尤其适合突发式数据传送。 三种传输时序图\n这东西不会画就可以埋了，做计算题必须要画的图\n为什么是斜的：电磁波在信道中传播需要花费时间（即使非常短），这部分时间也叫传播时延。有些题明确指出传播时延忽略不计时，那就必须要画平了。\n分类 记一下拓扑结构就好了\n分布范围：广域网、城域网、局域网、个人区域网\n传输技术：广播式网络、点对点网络\n拓扑规则：\n总线型：优点是建网容易、增删节点方便、节省线路；缺点是重负载时通信效率不高，总线任意一处对故障敏感。 星形网络：优点是便于集中控制和管理；缺点是成本高、中央设备对故障敏感。 环形网络：典型例子是令牌环局域网。 网状网络：每个节点至少有两条路径与其他节点相连，常用于广域网。优点是可靠性高，缺点是控制复杂、线路成本高。 使用者：公用网、专用网\n传输介质：有线网络、无线网络。\n🌟性能指标 这个不会就真埋了吧\n速率：节点在数字信道上传送数据的速率，也称数据传输速率、数据率或比特率。\n单位：b/s或bit/s 数据率较高时，可用Kb/s、Mb/s、Gb/s等。 放到常见情形，可以对应下载速率或上传速率\n在计网中，K=10^3，M=10^6，G=10^9，幂数每一级+3\n带宽：在计网中，表示网络等通信线路所能传送数据的能力。\n也就是最高数据传输速率\n单位：bit/s 吞吐量：单位时间内通过某个网络（或信道、接口）的实际数据量。\n常用于对实际网络的测量，以便获知有多少数据量能够通过网络。 🌟时延：指数据从网络的一段传送到另一段所需的总时间。由四部分组成：发送时延、传播时延、处理时延和排队时延。\n发送时延：又称传输时延，节点将分组的所有比特推向链路所花的时间。 即从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所花的时间。\n公式：发送时延 = 分组长度 / 发送速率 传播时延：电磁波在信道中传播一定距离所花时间，即一个比特从链路的一端到另一段所需时间。 公式：传播时延 = 信道长度 / 电磁波在信道上的传播速率 传输时延和传播时延一定要区分开，不然没分了\n处理时延：分组在交换节点为存储转发而进行的一些必要处理所花的时间。 排队时延：分组在路由器的输入队列或输出队列中排队等待所花时间。 处理时延与排队时延一般忽略不计，或者题目直接给出时间。 因此，总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延\n时延带宽积：指发送端发送的第一个比特即将到达终点时，发送端已经发送了多少比特。\n时延带宽积 = 传播时延 x 信道带宽\n想象成圆柱形管道，长度为传播时延，横截面积表示链路带宽，则时延带宽积表示该管道可以容纳的比特数量。\n🌟往返时延（RTT）：指从发送端发出一个短分组，到发送端收到来自接收端的确认（接收端收到数据后立刻发送确认）总共经历的时间。\nRTT包括各中间节点的处理时延、排队时延以及转发数据时的发送时延。\n信道利用率：指出信道有数据通过时间占总时间的百分比\n信道利用率 = 有数据通过时间 / （有数据通过时间 + 无数据通过时间） 信道利用率并非越高越好，太低会浪费资源，太高会造成拥堵。 ","date":"2025-02-28T00:00:00Z","permalink":"https://deathofbrain.github.io/p/network-key-points/","title":"计算机网络"},{"content":"绪论 数据结构的基本概念 逻辑结构\n逻辑结构是指数据对象中数据元素之间的相互关系，即从逻辑上描述数据元素之间的关系。\n注意与存储结构之间做区分\n逻辑结构分为线性结构和非线性结构，再细分为集合结构、线性结构、树形结构和图形结构。\n基本上是判断一个数据结构是属于哪种逻辑结构，所以心中有数就好。\n存储结构\n存储结构则是指数据对象中数据元素之间的存储关系，即从物理上描述数据元素之间的关系。\n逻辑结构是你看到的，存储结构是计算机看到的。\n存储结构分为\n顺序存储结构：逻辑上相邻的元素在物理上也相邻 链式存储结构：逻辑上相邻的元素在物理上不一定相邻 索引存储结构：在存储结构中增加附加的索引表 散列存储结构：根据关键字直接计算出存储地址 数据的运算 数据的运算是指对数据对象进行的操作，包括运算的定义和运算的实现两个方面。\n注意：运算的定义是针对逻辑结构的（如树的遍历等），运算的实现是针对存储结构的（对树的遍历来说，顺序存储和链式存储算法实现一定不同）。\n注意点：\n数据的逻辑结构独立于存储结构\n图的邻接表和邻接矩阵都可以表示图这种逻辑结构。\n在存储数据时，不仅要存储数据元素本身，还要存储数据元素之间的逻辑关系。\n时间复杂度和空间复杂度 (⭐) 每年必考，常见于选择题第一题和算法题第三小问。其中算法题主要是去研究你写的算法的时空复杂度，选择题则是考察一段代码的时空复杂度。\n时空复杂度的加法规则和乘法规则\n加法规则：$T(n) = O(max(f(n),g(n)))$\n两个算法串行执行时，时间复杂度取最大值\n例：\n1 2 3 4 5 6 7 8 9 10 11 void func1(int n){ for (int i = 0; i \u0026lt; n; i++) { printf(\u0026#34;Hello World\\n\u0026#34;); } // O(n) for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { printf(\u0026#34;Hello World\\n\u0026#34;); } } // O(n^2) } // func的时间复杂度为O(n^2) 乘法规则：$T(n) = O(f(n) \\times g(n))$\n两个算法嵌套执行时，时间复杂度相乘\n例：\n1 2 3 4 5 void func2(int n){ for (int i = 0; i \u0026lt; n; i++) { // O(n) func1(n); // O(n^2) } // O(n) * O(n^2) = O(n^3) } // func2的时间复杂度为O(n^3) 计算时间复杂度的通用办法\n单层嵌套 待续……\n","date":"2024-12-24T00:00:00Z","permalink":"https://deathofbrain.github.io/p/structure-key-points/","title":"数据结构"}]