[{"content":" 我讨厌上没有意思的班\n启程 闲来无事，突然想学Vim了。直到现在也只会基本操作，惨\n参考文献：\n《学习vi与Vim编辑器 8th Edition》 Vim三大模式介绍 Vim分为三个模式：普通模式、插入模式、ex模式\n普通模式： 当按键用于执行命令时的模式，一开始进Vim时就是普通模式，通过按Esc进入。请注意，vi与Vim在普通模式时指令区分大小写 普通模式又称命令模式，即按键只处理命令，不直接插入到文本\n插入模式 通过按i键进入，插入模式允许用户直接在光标处编辑文本，就像notepad一样 ex模式 在普通模式通过输入:进入，ex模式允许用户输入ex指令完成单行或跨行编辑，同样区分大小写。 ex命令是ex行编辑器使用的指令，ex行编辑器是古早Unix系统使用的单行终端编辑器，属于Linux底层编辑器\n一般来说，普通模式用于快速翻阅代码或快捷更改字符或删除行等，插入模式用于普通编辑文本，ex模式则用于搜索全文，或使用高级指令完成编辑操作等。\n打开文件 一句话：vim [filename]\n当然，有可能你需要先安装vim（笑）\n操作模式 第一次使用Vim时，你是否也曾敲打键盘，却没有任何字符输入？甚至莫名其妙把内容删除了？ 普通模式是这样的，当进入Vim时，默认会进入普通模式，此时键盘上每个按键都代表一个指令，而非代表内容的文本。\n请注意，并非所有按键都有对应的命令，而是说在普通模式中，Vim认为接收到的按键代表的是“命令”。 此时，若想输入文本，请确保在小写状态下，按下i键，进入插入模式，此时再键入的就是文本本身了。\n保存，或者直接退出 恭喜你，终于用Vim成功写了一点东西，也许是代码，也许是随便乱打的，那么来到了第二个问题：我该怎么退出这沟槽的Vim？\n保存退出\n在普通模式下，按下Shift+zz，也就是输入两个大写的Z，这个是保存并退出指令，在一切顺利的情况下，Vim会将缓存区中的文本写入文件，并退出程序。\n不知道现在是什么模式？多按几下Esc，就一定处于命令模式！\n强制退出\n有时候，因为某些原因（虽然大多数是只读问题），Vim无法保存文件，并且会提示包括[Read only]的信息。\n别慌，Vim可以通过ex指令实现强制退出。\n还记得怎么进入ex模式吗？按下Shift+；，也就是输入:，此时你会看到终端最下面出现了:，这代表着你成功进入了ex模式。\n紧接着，输入q!，按下Enter，成功退出！并且不会保存任何文件。\n!在ex模式中代表强制，刚才的指令就是强制退出的意思。一般来说，如果没有修改任何文件的话，输入q就可以了。 当然，ex指令下也可以保存退出，只需要输入:wq并回车就可以了。具体指令会在后面详解。 同时，从现在开始，将不再重复强调如何进入某种模式，也不再强调ex模式下需要用回车来执行指令。\n另存为\nex模式下输入w [filename]，即可另存为新文件。 当然，输入w! [filename]会将内容覆盖到已存在的文件中，无法撤回！\n使用!时还请三思。\n简单（？）的文本编辑 一般来说，学习上面内容后，就可以使用Vim简单进行编辑了，不过，在面对几千行的代码时，若是用方向键+插入去修改的话，我猜你肯定很想砸键盘。\n这部分内容主要讲述如何在上文基础上，使用简单易学的操作提高一些编辑的效率，让你砸键盘的欲望变得小一点。\n","date":"2025-08-04T00:00:00Z","permalink":"https://deathofbrain.github.io/p/vim/","title":"Vim之旅"},{"content":"前言 我要（被迫）二战了，给我自己准备的，到时候平板摸鱼能看 捞干的讲\n一、计算机网络概述 基本概念 ▲计算机网络的概念\n定义：将地理位置不同，具有独立功能的多台计算机以及外部设备通过通信线路连接起来，实现资源共享和信息传递的操作系统。\n计算机网络组成\n","date":"2025-02-28T00:00:00Z","permalink":"https://deathofbrain.github.io/p/network-key-points/","title":"计算机网络"},{"content":"前言 我要（被迫）二战了，给我自己准备的，到时候平板摸鱼能看 捞干的讲\n绪论 数据结构的基本概念 逻辑结构\n逻辑结构是指数据对象中数据元素之间的相互关系，即从逻辑上描述数据元素之间的关系。\n注意与存储结构之间做区分\n逻辑结构分为线性结构和非线性结构，再细分为集合结构、线性结构、树形结构和图形结构。\n基本上是判断一个数据结构是属于哪种逻辑结构，所以心中有数就好。\n存储结构\n存储结构则是指数据对象中数据元素之间的存储关系，即从物理上描述数据元素之间的关系。\n逻辑结构是你看到的，存储结构是计算机看到的。\n存储结构分为\n顺序存储结构：逻辑上相邻的元素在物理上也相邻 链式存储结构：逻辑上相邻的元素在物理上不一定相邻 索引存储结构：在存储结构中增加附加的索引表 散列存储结构：根据关键字直接计算出存储地址 数据的运算 数据的运算是指对数据对象进行的操作，包括运算的定义和运算的实现两个方面。\n注意：运算的定义是针对逻辑结构的（如树的遍历等），运算的实现是针对存储结构的（对树的遍历来说，顺序存储和链式存储算法实现一定不同）。\n注意点：\n数据的逻辑结构独立于存储结构\n图的邻接表和邻接矩阵都可以表示图这种逻辑结构。\n在存储数据时，不仅要存储数据元素本身，还要存储数据元素之间的逻辑关系。\n时间复杂度和空间复杂度 (⭐) 每年必考，常见于选择题第一题和算法题第三小问。其中算法题主要是去研究你写的算法的时空复杂度，选择题则是考察一段代码的时空复杂度。\n时空复杂度的加法规则和乘法规则\n加法规则：$T(n) = O(max(f(n),g(n)))$\n两个算法串行执行时，时间复杂度取最大值\n例：\n1 2 3 4 5 6 7 8 9 10 11 void func1(int n){ for (int i = 0; i \u0026lt; n; i++) { printf(\u0026#34;Hello World\\n\u0026#34;); } // O(n) for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { printf(\u0026#34;Hello World\\n\u0026#34;); } } // O(n^2) } // func的时间复杂度为O(n^2) 乘法规则：$T(n) = O(f(n) \\times g(n))$\n两个算法嵌套执行时，时间复杂度相乘\n例：\n1 2 3 4 5 void func2(int n){ for (int i = 0; i \u0026lt; n; i++) { // O(n) func1(n); // O(n^2) } // O(n) * O(n^2) = O(n^3) } // func2的时间复杂度为O(n^3) 计算时间复杂度的通用办法\n单层嵌套 待续……\n","date":"2024-12-24T00:00:00Z","permalink":"https://deathofbrain.github.io/p/structure-key-points/","title":"数据结构"}]