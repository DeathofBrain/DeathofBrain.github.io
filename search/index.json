[{"content":"前言 对于408应试来说，最重要的环节一在于每个知识点的掌握，二在于对常见题型的完全掌握，对新颖题型的从容应对，才能在老头一次又一次的刁难中不败下阵来。这一系列文章就是为了能让备考408的各位，在复习知识点的同时，对常见题型能做到百发百中，对冷门考点能做到心中有数。\n本文默认各位同学对408中术语的概念有一定的了解，因此本文适合已经结束一轮复习，对于计科四大件的大部分知识点都有印象，却对408针对考点的具体题型不是很了解的同学。当然，这个文章应该也能在对一轮复习的同学中起到一定的帮助。\n绪论 数据结构的基本概念 此为25考纲新加（25没考），笔者认为此处应仅考察数据结构三要素相关内容。\n逻辑结构\n逻辑结构是指数据对象中数据元素之间的相互关系，即从逻辑上描述数据元素之间的关系。\n注意与存储结构之间做区分\n逻辑结构分为线性结构和非线性结构，再细分为集合结构、线性结构、树形结构和图形结构。\n考试中应该是让你判断一个数据结构是属于哪种逻辑结构，所以心中有数就好。\n存储结构\n存储结构则是指数据对象中数据元素之间的存储关系，即从物理上描述数据元素之间的关系。\n白话讲就是逻辑结构是你看到的，存储结构是计算机看到的。\n存储结构分为\n顺序存储结构：逻辑上相邻的元素在物理上也相邻 链式存储结构：逻辑上相邻的元素在物理上不一定相邻 索引存储结构：在存储结构中增加附加的索引表 散列存储结构：根据关键字直接计算出存储地址 数据的运算 数据的运算是指对数据对象进行的操作，包括运算的定义和运算的实现两个方面。\n注意：运算的定义是针对逻辑结构的（如树的遍历等），运算的实现是针对存储结构的（对树的遍历来说，顺序存储和链式存储算法实现一定不同）。\n注意点：\n数据的逻辑结构独立于存储结构\n图的邻接表和邻接矩阵都可以表示图这种逻辑结构。\n在存储数据时，不仅要存储数据元素本身，还要存储数据元素之间的逻辑关系。\n时间复杂度和空间复杂度 (⭐) 每年必考，常见于选择题第一题和算法题第三小问。其中算法题主要是去研究你写的算法的时空复杂度，选择题则是考察一段代码的时空复杂度。\n时空复杂度的加法规则和乘法规则\n加法规则：$T(n) = O(max(f(n),g(n)))$\n两个算法串行执行时，时间复杂度取最大值\n例：\n1 2 3 4 5 6 7 8 9 10 11 void func1(int n){ for (int i = 0; i \u0026lt; n; i++) { printf(\u0026#34;Hello World\\n\u0026#34;); } // O(n) for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { printf(\u0026#34;Hello World\\n\u0026#34;); } } // O(n^2) } // func的时间复杂度为O(n^2) 乘法规则：$T(n) = O(f(n) \\times g(n))$\n两个算法嵌套执行时，时间复杂度相乘\n例：\n1 2 3 4 5 void func2(int n){ for (int i = 0; i \u0026lt; n; i++) { // O(n) func1(n); // O(n^2) } // O(n) * O(n^2) = O(n^3) } // func2的时间复杂度为O(n^3) 计算时间复杂度的通用办法\n单层嵌套 1. ","date":"2024-12-24T00:00:00Z","permalink":"https://deathofbrain.github.io/p/data-structure-key-points/","title":"408数据结构考点+题型"},{"content":"总归是要写点东西的 还是没有搞定时钟和背景虚化\n","date":"2024-12-24T00:00:00Z","permalink":"https://deathofbrain.github.io/p/hugo-decorate/","title":"Hugo装修历程"}]