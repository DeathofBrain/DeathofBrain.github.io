<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on DeathofBrain的小屋</title>
        <link>https://deathofbrain.github.io/post/</link>
        <description>Recent content in Posts on DeathofBrain的小屋</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>DeathofBrain</copyright>
        <lastBuildDate>Thu, 14 Aug 2025 15:24:39 +0000</lastBuildDate><atom:link href="https://deathofbrain.github.io/post/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Vim之旅</title>
        <link>https://deathofbrain.github.io/p/vim/</link>
        <pubDate>Mon, 04 Aug 2025 00:00:00 +0000</pubDate>
        
        <guid>https://deathofbrain.github.io/p/vim/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;此文档使用VSCode+Vim模拟插件进行编写&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;启程&#34;&gt;启程
&lt;/h2&gt;&lt;p&gt;闲来无事，突然想学Vim了。直到现在也只会基本操作，惨&lt;/p&gt;
&lt;p&gt;参考文献：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《学习vi与Vim编辑器 8th Edition》&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;vim三大模式介绍&#34;&gt;Vim三大模式介绍
&lt;/h3&gt;&lt;p&gt;Vim分为三个模式：普通模式、插入模式、ex模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;普通模式&lt;/p&gt;
&lt;p&gt;当按键用于执行命令时的模式，一开始进Vim时就是普通模式，通过按Esc进入。请注意，vi与Vim在普通模式时指令区分大小写&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;普通模式又称命令模式，即按键只处理命令，不直接插入到文本&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;插入模式&lt;/p&gt;
&lt;p&gt;通过按&lt;code&gt;i&lt;/code&gt;键进入，插入模式允许用户直接在光标处编辑文本，就像notepad一样&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ex模式&lt;/p&gt;
&lt;p&gt;在普通模式通过输入&lt;code&gt;:&lt;/code&gt;进入，ex模式允许用户输入ex指令完成单行或跨行编辑，同样区分大小写。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ex命令是ex行编辑器使用的指令，ex行编辑器是古早Unix系统使用的单行终端编辑器，属于Linux底层编辑器&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般来说，普通模式用于快速翻阅代码或快捷更改字符或删除行等，插入模式用于普通编辑文本，ex模式则用于搜索全文，或使用高级指令完成编辑操作等。&lt;/p&gt;
&lt;h3 id=&#34;打开文件&#34;&gt;打开文件
&lt;/h3&gt;&lt;p&gt;一句话：&lt;code&gt;vim [filename]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当然，有可能你需要先安装vim（笑）&lt;/p&gt;
&lt;h3 id=&#34;操作模式&#34;&gt;操作模式
&lt;/h3&gt;&lt;p&gt;第一次使用Vim时，你是否也曾敲打键盘，却没有任何字符输入？甚至莫名其妙把内容删除了？&lt;/p&gt;
&lt;p&gt;普通模式是这样的，当进入Vim时，默认会进入普通模式，此时键盘上每个按键都代表一个指令，而非代表内容的文本。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请注意，并非所有按键都有对应的命令，而是说在普通模式中，Vim认为接收到的按键代表的是“命令”。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;此时，若想输入文本，请确保在小写状态下，按下&lt;code&gt;i&lt;/code&gt;键，进入插入模式，此时再键入的就是文本本身了。&lt;/p&gt;
&lt;h4 id=&#34;保存或者直接退出&#34;&gt;保存，或者直接退出
&lt;/h4&gt;&lt;p&gt;恭喜你，终于用Vim成功写了一点东西，也许是代码，也许是随便乱打的，那么来到了第二个问题：我该怎么退出这沟槽的Vim？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;保存退出&lt;/p&gt;
&lt;p&gt;在普通模式下，按下&lt;code&gt;Shift&lt;/code&gt;+&lt;code&gt;zz&lt;/code&gt;，也就是输入两个&lt;strong&gt;大写&lt;/strong&gt;的Z，这个是&lt;em&gt;保存并退出&lt;/em&gt;指令，在一切顺利的情况下，Vim会将缓存区中的文本写入文件，并退出程序。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不知道现在是什么模式？多按几下&lt;code&gt;Esc&lt;/code&gt;，就一定处于命令模式！&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;强制退出&lt;/p&gt;
&lt;p&gt;有时候，因为某些原因（虽然大多数是只读问题），Vim无法保存文件，并且会提示包括&lt;code&gt;[Read only]&lt;/code&gt;的信息。&lt;/p&gt;
&lt;p&gt;别慌，Vim可以通过ex指令实现强制退出。&lt;/p&gt;
&lt;p&gt;还记得怎么进入ex模式吗？按下&lt;code&gt;Shift&lt;/code&gt;+&lt;code&gt;；&lt;/code&gt;，也就是输入&lt;code&gt;:&lt;/code&gt;，此时你会看到终端最下面出现了&lt;code&gt;:&lt;/code&gt;，这代表着你成功进入了ex模式。&lt;/p&gt;
&lt;p&gt;紧接着，输入&lt;code&gt;q!&lt;/code&gt;，按下&lt;code&gt;Enter&lt;/code&gt;，成功退出！并且不会保存任何文件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;!&lt;/code&gt;在ex模式中代表&lt;strong&gt;强制&lt;/strong&gt;，刚才的指令就是强制退出的意思。一般来说，如果没有修改任何文件的话，输入q就可以了。&lt;/p&gt;
&lt;p&gt;当然，ex指令下也可以保存退出，只需要输入&lt;code&gt;:wq&lt;/code&gt;并回车就可以了。具体指令会在后面详解。&lt;/p&gt;
&lt;p&gt;同时，从现在开始，将不再重复强调如何进入某种模式，也不再强调ex模式下需要用回车来执行指令。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另存为&lt;/p&gt;
&lt;p&gt;ex模式下输入&lt;code&gt;w [filename]&lt;/code&gt;，即可另存为新文件。
当然，输入&lt;code&gt;w! [filename]&lt;/code&gt;会将内容&lt;strong&gt;覆盖&lt;/strong&gt;到已存在的文件中，无法撤回！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用&lt;code&gt;!&lt;/code&gt;时还请三思。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;简单的文本编辑&#34;&gt;简单（？）的文本编辑
&lt;/h2&gt;&lt;p&gt;一般来说，学习上面内容后，就可以使用Vim简单进行编辑了，不过，在面对几千行的代码时，若是用方向键+插入去修改的话，我猜你肯定很想砸键盘。&lt;/p&gt;
&lt;p&gt;这部分内容主要讲述如何在上文基础上，使用简单易学的操作提高一些编辑的效率，让你砸键盘的欲望变得小一点。&lt;/p&gt;
&lt;h3 id=&#34;vi命令&#34;&gt;vi命令
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;复习：上文中，Vim有几种模式？都以什么方式进入？&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Tips：可以将不同的模式想像成不同的键盘，在插入模式中，键盘功能就像平常一样。在普通模式中，每个键都有新的含义或是代表某种动作。&lt;/p&gt;
&lt;p&gt;在你按&lt;code&gt;Esc&lt;/code&gt;之前，插入命令之后的所有按键输入都被视为文本。&lt;/p&gt;
&lt;h3 id=&#34;移动光标&#34;&gt;移动光标
&lt;/h3&gt;&lt;p&gt;在进行编辑工作（看代码）的时候，更多的时候都是在文件中四处移动，使用各种命令编辑现有文本。&lt;/p&gt;
&lt;p&gt;本节首先讲述最基本的光标移动操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按上下左右四个方向将光标一次移动一个字符位置&lt;/li&gt;
&lt;li&gt;按照文本块（单词、句子或段落）向前或向后移动光标&lt;/li&gt;
&lt;li&gt;在文件中以&lt;strong&gt;屏&lt;/strong&gt;为单位移动光标&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;单一移动&#34;&gt;单一移动
&lt;/h4&gt;&lt;p&gt;虽然Vim支持方向键移动光标，但是更常用&lt;code&gt;h&lt;/code&gt;、&lt;code&gt;j&lt;/code&gt;、&lt;code&gt;k&lt;/code&gt;、&lt;code&gt;l&lt;/code&gt;进行光标移动。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;h&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;向左移动一个位置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;j&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;移动到下一行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;k&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;移动到上一行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;l&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;向右移动一个字符位置&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种移动方式的好处是：你的手指可以在不离开键盘中心区域的情况下四处移动光标。&lt;/p&gt;
&lt;p&gt;当然，移动光标前，请确保你在命令模式下使用。&lt;/p&gt;
&lt;h4 id=&#34;数量级参数&#34;&gt;数量级参数
&lt;/h4&gt;&lt;p&gt;在&lt;strong&gt;命令&lt;/strong&gt;前输入数字，此时这个数字被称为重复计数（repeat count）或复制因子（replication factor）&lt;/p&gt;
&lt;p&gt;现在，在Vim试一下&lt;code&gt;4l&lt;/code&gt;吧，你会发现，光标向右移动了四个位置，也就相当于你一次输入了4个&lt;code&gt;l&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当然，数字的输入要在命令&lt;strong&gt;之前&lt;/strong&gt;，否则Vim永远也不知道数字的输入何时结束。&lt;/p&gt;
&lt;h4 id=&#34;行内移动&#34;&gt;行内移动
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;移动到行首：&lt;code&gt;0&lt;/code&gt;（数字0）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;移动到行尾：&lt;code&gt;$&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;这里的行指的是文件中实际的一行，可以通过ex命令输入&lt;code&gt;set nu&lt;/code&gt;查看文件行号。&lt;/p&gt;
&lt;p&gt;也就是说，使用行首行尾移动时，有可能在屏幕中显示为跳转多个行，但实际上光标只在一行文本中移动。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h4 id=&#34;按文本块移动&#34;&gt;按文本块移动
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;请注意大小写&lt;/p&gt;
&lt;p&gt;此处的文本块仅指单词，后续部分会介绍按句子，按段落等。&lt;/p&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;w&lt;/code&gt;：光标向右移动一个单词（由字母数字字符组成）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请注意，此时单个符号和标点也视为一个单词。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;W&lt;/code&gt;：光标向右移动一个用空格分割的段&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;w&lt;/code&gt;会跳转到下一个符号或空格后第一个字符处，而&lt;code&gt;W&lt;/code&gt;仅会跳转到下一个空格后第一个字符处。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;b&lt;/code&gt;：光标向左移动一个单词&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;B&lt;/code&gt;：光标向左移动一个用空格分割的段&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;G&lt;/code&gt;：光标跳转到指定的行&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;单独的&lt;code&gt;G&lt;/code&gt;会跳转到文件末尾，在&lt;code&gt;G&lt;/code&gt;前面添加数量参数时，会跳转到文件指定的行，如&lt;code&gt;42G&lt;/code&gt;会跳转到文件42行。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上的指令都可以加入数量参数，如&lt;code&gt;2W&lt;/code&gt;会让光标向右移动两个用空格分割的段。&lt;/p&gt;
&lt;h3 id=&#34;修改文本&#34;&gt;修改文本
&lt;/h3&gt;&lt;h4 id=&#34;插入新文本&#34;&gt;插入新文本
&lt;/h4&gt;&lt;p&gt;前面说过，&lt;code&gt;i&lt;/code&gt;键会进入插入模式。&lt;/p&gt;
&lt;p&gt;当按下&lt;code&gt;i&lt;/code&gt;键时，请注意，此时插入光标（小竖线）是在光标（在字符闪烁的小块）的&lt;strong&gt;左边&lt;/strong&gt;的，万分注意。&lt;/p&gt;
&lt;h4 id=&#34;追加文本&#34;&gt;追加文本
&lt;/h4&gt;&lt;p&gt;追加文本，顾名思义，就是将插入光标放置在光标&lt;strong&gt;右边&lt;/strong&gt;，随后进入插入模式。&lt;/p&gt;
&lt;p&gt;某种意义上，&lt;code&gt;a&lt;/code&gt;键也是进入插入模式的一种方式。&lt;/p&gt;
&lt;h4 id=&#34;更改文本&#34;&gt;更改文本
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;c&lt;/code&gt;键为更改命令，需要指定范围，一般与移动命令结合使用。&lt;/p&gt;
&lt;p&gt;一旦生效，更改命令会删除指定范围字符，并且自动进入插入模式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;还记得上面的移动指令吗？&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;例如：&lt;code&gt;c&lt;/code&gt;可用于更改从光标位置开始的文本：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cw&lt;/code&gt;：从&lt;strong&gt;光标位置&lt;/strong&gt;到单词结尾&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c2b&lt;/code&gt;：从光标位置向左两个单词&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c$&lt;/code&gt;：从光标位置到行尾&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c0&lt;/code&gt;：从光标位置到行首&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与&lt;code&gt;i&lt;/code&gt;和&lt;code&gt;a&lt;/code&gt;一样，在按&lt;code&gt;Esc&lt;/code&gt;之前，你一直都处于插入模式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;cw&lt;/code&gt;指令取决于光标位置，若是光标在单词中间，则只会更改单词中间到结尾的字符。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h4 id=&#34;整行更改&#34;&gt;整行更改
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;cc&lt;/code&gt;对整行文本进行更改，无论光标处于该行何种位置，&lt;code&gt;cc&lt;/code&gt;都会替换掉整行文本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;C&lt;/code&gt;或&lt;code&gt;c$&lt;/code&gt;来替换从&lt;strong&gt;当前光标位置&lt;/strong&gt;到行尾的所有字符。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;无论是&lt;code&gt;cc&lt;/code&gt;还是&lt;code&gt;C&lt;/code&gt;，都不用在指令末尾指定文字对象，但是可以在指令前面添加数量参数。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h4 id=&#34;字符更改&#34;&gt;字符更改
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;r&lt;/code&gt;是另一个用于替换文本的命令，该命令使用一个字符替换另一个字符，且无需按&lt;code&gt;Esc&lt;/code&gt;就可以返回命令模式。&lt;/p&gt;
&lt;p&gt;格式：&lt;code&gt;[数量参数] r [要替换成的字符]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注意：数量参数会让后面多个字符替换成同一个字符。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;s&lt;/code&gt;与&lt;code&gt;r&lt;/code&gt;的作用与命令格式相同，不同的是，使用&lt;code&gt;s&lt;/code&gt;更改后，会进入到插入模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;S&lt;/code&gt;命令可以替换整行文本，且不同于&lt;code&gt;C&lt;/code&gt;命令，&lt;code&gt;S&lt;/code&gt;命令会删除整行，之后进入插入模式，光标置于行首。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在前面加上数量参数，可以实现多行删除并进入到插入模式。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;R&lt;/code&gt;命令比较特殊，不同于&lt;code&gt;r&lt;/code&gt;，该命令会直接进入&lt;strong&gt;改写模式&lt;/strong&gt;，此时键盘输入的字符会直接逐个替换屏幕上的文本，直到按下&lt;code&gt;Esc&lt;/code&gt;。并且，当删除替换字符时，原先字符会恢复。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当按下&lt;code&gt;Enter&lt;/code&gt;时，编辑器会插入新行。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;更改大小写英文&#34;&gt;更改大小写（英文）
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;~&lt;/code&gt;可以对光标所处字符更改大小写。同样，输入数量参数可以对多个字符更改。&lt;/p&gt;
&lt;p&gt;若想更改多行，只能使用Unix指令，后面会讲解。&lt;/p&gt;
&lt;h3 id=&#34;删除文本&#34;&gt;删除文本
&lt;/h3&gt;&lt;p&gt;删除命令&lt;code&gt;d&lt;/code&gt;可用于删除文件中的任意文本。和更改命令一样，删除命令也需要文本对象。&lt;/p&gt;
&lt;p&gt;无论哪种形式的删除命令，都要先将光标移动到待删除文本的起始位置，然后输入删除命令&lt;code&gt;d&lt;/code&gt;和文本对象。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其实，文本对象指的就是像&lt;code&gt;w&lt;/code&gt;，&lt;code&gt;2w&lt;/code&gt;一类的东西，也可以是&lt;code&gt;l&lt;/code&gt;，&lt;code&gt;2l&lt;/code&gt;这种移动指令，这会向后删除两个字符。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h4 id=&#34;单词&#34;&gt;单词
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;dw&lt;/code&gt;删除从光标所在位置开始的第一个单词。注意，单词之后的空格也会被一并删除。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;若想保留单词之后的空格，可以使用&lt;code&gt;de&lt;/code&gt;而不是&lt;code&gt;dw&lt;/code&gt;。若想连带后面标点符号也删除，请使用&lt;code&gt;dE&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;e&lt;/code&gt;指令为到达下一个单词末尾，而&lt;code&gt;E&lt;/code&gt;则移动到下一个空格分隔的单词尾部。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h4 id=&#34;行&#34;&gt;行
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;dd&lt;/code&gt;：删除整个行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;D&lt;/code&gt;：从光标开始删除到末尾（等同于&lt;code&gt;d$&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;字符&#34;&gt;字符
&lt;/h4&gt;&lt;p&gt;往往，可能仅仅只是删除某个字符，却不需要修改。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;x&lt;/code&gt;命令仅删除光标所在的字符，同样，也可以加入数量参数，删除光标及之后的更多字符。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;X&lt;/code&gt;命令则会删除光标之前的字符，支持数量参数。&lt;/p&gt;
&lt;p&gt;二者使用后都会保持命令模式不变。&lt;/p&gt;
&lt;h3 id=&#34;撤回&#34;&gt;撤回
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;u&lt;/code&gt;可以撤回上一次的&lt;strong&gt;操作&lt;/strong&gt;（如&lt;code&gt;dd&lt;/code&gt;）（Undo）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;U&lt;/code&gt;可以恢复一整行文本到原先状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Ctrl+r&lt;/code&gt;可以恢复上一次的撤回操作（Redo）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.&lt;/code&gt;可以重复上一次的指令&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;请注意，以上操作仅限于在命令模式中删除（像&lt;code&gt;x&lt;/code&gt;、&lt;code&gt;dd&lt;/code&gt;）的情况，在插入模式中删除时，仅靠&lt;code&gt;u&lt;/code&gt;并不能实现，保持插入模式之后&lt;code&gt;Ctrl+Z&lt;/code&gt;就可以了。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;移动文本&#34;&gt;移动文本
&lt;/h3&gt;&lt;p&gt;每次删除一个文本块，被删除的内容就会被保存在一个特殊的无名区域，称为&lt;strong&gt;删除寄存器&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那么，在Vim中，剪切文本的操作就是删除-&amp;gt;选取位置-&amp;gt;用放置命令&lt;code&gt;p&lt;/code&gt;这样的流程实现的。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>计算机网络</title>
        <link>https://deathofbrain.github.io/p/network-key-points/</link>
        <pubDate>Fri, 28 Feb 2025 00:00:00 +0000</pubDate>
        
        <guid>https://deathofbrain.github.io/p/network-key-points/</guid>
        <description>&lt;h2 id=&#34;计算机网络体系结构&#34;&gt;计算机网络体系结构
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;本章内容重点：三种交换（计算）、OSI分层、TCP/IP分层（记忆）、各种指标与单位（计算）&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;概述&#34;&gt;▲概述
&lt;/h3&gt;&lt;h4 id=&#34;概念&#34;&gt;▲概念
&lt;/h4&gt;&lt;p&gt;定义：将地理位置不同，具有独立功能的多台计算机以及外部设备通过通信线路连接起来，实现&lt;strong&gt;资源共享&lt;/strong&gt;和信息传递的操作系统。&lt;/p&gt;
&lt;h4 id=&#34;组成&#34;&gt;组成
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;需要知道哪些东西是哪个部分的就可以了&lt;/p&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;从组成部分看，计算机网络主要由&lt;strong&gt;硬件&lt;/strong&gt;、&lt;strong&gt;软件&lt;/strong&gt;、&lt;strong&gt;协议&lt;/strong&gt;三大部分组成。
&lt;ul&gt;
&lt;li&gt;硬件：由主机、通信链路、交换设备和网卡等组成&lt;/li&gt;
&lt;li&gt;软件：包括email程序、ftp程序等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;协议&lt;/strong&gt;：计算机网络的核心，规定了网络传输数据时所遵循的规范。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;从工作方式看，可分为&lt;strong&gt;边缘部分&lt;/strong&gt;和&lt;strong&gt;核心部分&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;边缘部分：由所有连接到互联网上的供用户直接使用的主机构成，进行通信和资源共享。&lt;/li&gt;
&lt;li&gt;核心部分：大量网络和连接着的路由器组成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;从功能组成看，可分为&lt;strong&gt;通信子网&lt;/strong&gt;和&lt;strong&gt;资源子网&lt;/strong&gt;。
&lt;ul&gt;
&lt;li&gt;通信子网：各种传输介质、通信设备和相应网络协议组成。
&lt;ul&gt;
&lt;li&gt;使网络具有数据传输、交换、控制和存储的能力，实现数据通信。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;资源子网：实现资源共享的设备及其软件的集合
&lt;ul&gt;
&lt;li&gt;向网络用户提供共享其他计算机上的硬件资源、软件资源、数据资源的服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;功能&#34;&gt;功能
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;数据通信&lt;/strong&gt;：最基本和最重要的功能，实现联网计算机之间信息的传输。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;资源共享&lt;/strong&gt;：共享软件、硬件、数据，让网络中资源互通有无。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分布式处理&lt;/strong&gt;：将某个复杂的任务分配给网络中其它计算机系统，提高整个系统的利用率。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提高可靠性&lt;/strong&gt;：网络中的各台计算机可以互为替代机。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;负载均衡&lt;/strong&gt;：将工作任务均衡地分配给网络中各台计算机。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;电路交换报文交换和分组交换&#34;&gt;🌟电路交换、报文交换和分组交换
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;计网计算题重点，可结合到多种题型&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;路由器&lt;/strong&gt;这个&lt;strong&gt;网络层&lt;/strong&gt;设备在网络核心部分起到重要作用。它对收到的分组进行&lt;strong&gt;存储转发&lt;/strong&gt;实现&lt;strong&gt;分组交换&lt;/strong&gt;。分组交换是现代网络最常用的交换方式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从通信资源分配的角度看，交换就是按照某种方式动态地分配传输线路的资源。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;分组交换由电路交换与报文交换发展而来。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;电路交换（典型：电话网）
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;特点：在进行数据传输前，两个用户之间必须先建立一条专用的&lt;strong&gt;物理&lt;/strong&gt;通信路径，且传输过程中，这一路径始终被两个用户独占，直到通信结束被释放。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分为三步：建立连接（开始占用通信资源）、传输数据、释放连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2.png&#34;
	width=&#34;1070&#34;
	height=&#34;300&#34;
	srcset=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2_hu_24dc96a343a3143.png 480w, https://deathofbrain.github.io/p/network-key-points/images/%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2_hu_e500daeb0be2b7b3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;电路交换&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;356&#34;
		data-flex-basis=&#34;856px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;整条电路上任何节点都不进行存储，直接转发，&lt;strong&gt;不存在存储转发所耗费的时间&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这一点需要记住。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优点：通信时延小、有序传输、没有冲突、实时性强。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：建立连接时间长、线路利用率低、灵活性差、难以实现差错控制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;灵活性差：物理通路中，任何一点出现故障，就必须重新建立连接。&lt;/p&gt;
&lt;p&gt;难以实现差错控制：中间节点不具备存储和检验数据的能力，无法发现并纠正错误。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事实上，计算机之间的数据传输往往是突发式的（高频、少量数据），若使用电路交换，那么整个通信链路资源的利用率往往不到10%，甚至只有1%。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;报文交换——分组交换的前身&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据交换的单位是&lt;strong&gt;报文&lt;/strong&gt;。报文由用户数据、源地址和目的地址等信息组成。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;采用&lt;strong&gt;存储转发&lt;/strong&gt;技术，整个报文先传送到相邻的节点，&lt;strong&gt;全部存储&lt;/strong&gt;后查找转发表，转发到下一个节点，如此反复，直到报文到达目的节点。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;全部存储——报文交换被淘汰的原因&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不同于电路交换，每个报文都可单独选择到达目的端的路径。示例图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E6%8A%A5%E6%96%87%E4%BA%A4%E6%8D%A2.png&#34;
	width=&#34;474&#34;
	height=&#34;159&#34;
	srcset=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E6%8A%A5%E6%96%87%E4%BA%A4%E6%8D%A2_hu_be782a12be3cef81.png 480w, https://deathofbrain.github.io/p/network-key-points/images/%E6%8A%A5%E6%96%87%E4%BA%A4%E6%8D%A2_hu_529dea2db951d3c8.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;报文交换&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;298&#34;
		data-flex-basis=&#34;715px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优点：无建立连接时延、灵活分配线路、线路利用率高、支持差错控制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这些也是存储转发本身的优点。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：转发时延高、缓存开销大、错误处理低效。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;交换节点要把报文都存储完才能查找转发表转发到下一节点，若是报文太大，缓存开销也大，并且一旦丢包，重传代价也大。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分组交换，就是在报文交换&lt;strong&gt;存储转发&lt;/strong&gt;的基础上，将报文划分成若干较小&lt;strong&gt;等长&lt;/strong&gt;数据段，每个数据段前面添加一些由控制信息组成的&lt;strong&gt;首部&lt;/strong&gt;，构成&lt;strong&gt;分组（Packet）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E5%88%86%E7%BB%84.png&#34;
	width=&#34;1070&#34;
	height=&#34;384&#34;
	srcset=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E5%88%86%E7%BB%84_hu_fcdb989a9ab245d8.png 480w, https://deathofbrain.github.io/p/network-key-points/images/%E5%88%86%E7%BB%84_hu_a6569516edf2d64d.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;构成分组&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;278&#34;
		data-flex-basis=&#34;668px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;分组交换&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;流程&lt;/p&gt;
&lt;p&gt;源主机发送分组，分组交换网中的交换机收到分组后，先缓存，然后从首部提取目的地址，借由转发表，发送给下一个交换机，周而复始，直到到达目的主机。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本质上和报文交换一样&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优点：存储转发开销小、传输效率高、减少出错概率与代价。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;分组是逐个传输的，可以使后一个分组的存储操作与前一个分组的转发操作并行，形成&lt;strong&gt;流水线&lt;/strong&gt;，后面的图会详细表达。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：存在存储转发时延、需要传输额外信息、可能出现失序、丢失或重复分组的情况。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;失序丢包等问题是借由上层，或使用虚电路服务解决的，先不必深究。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;三种交换方式的比较&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当要连续传输大量的数据，并且传送时间远大于连接建立时间时，采用电路交换更合适。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;然而，现时代，数据的传送时间肯定小于连接建立时间。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从提高整个网络的信道利用率看，报文交换和分组交换更合适&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其中，分组交换比报文交换时延更小，更加灵活，尤其适合突发式数据传送。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;三种传输时序图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E4%BC%A0%E8%BE%93%E6%97%B6%E5%BA%8F%E5%9B%BE.png&#34;
	width=&#34;1156&#34;
	height=&#34;798&#34;
	srcset=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E4%BC%A0%E8%BE%93%E6%97%B6%E5%BA%8F%E5%9B%BE_hu_315c74c69a76b267.png 480w, https://deathofbrain.github.io/p/network-key-points/images/%E4%BC%A0%E8%BE%93%E6%97%B6%E5%BA%8F%E5%9B%BE_hu_27fbf94784fabc84.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;传输时序图&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;144&#34;
		data-flex-basis=&#34;347px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这东西不会画就可以埋了，做计算题必须要画的图&lt;/p&gt;
&lt;p&gt;为什么是斜的：电磁波在信道中传播需要花费时间（即使非常短），这部分时间也叫传播时延。有些题明确指出传播时延忽略不计时，那就必须要画平了。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;分类&#34;&gt;分类
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;记一下拓扑结构就好了&lt;/p&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;分布范围：广域网、城域网、局域网、个人区域网&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传输技术：广播式网络、点对点网络&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拓扑规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;总线型：优点是建网容易、增删节点方便、节省线路；缺点是重负载时通信效率不高，总线任意一处对故障敏感。&lt;/li&gt;
&lt;li&gt;星形网络：优点是便于集中控制和管理；缺点是成本高、中央设备对故障敏感。&lt;/li&gt;
&lt;li&gt;环形网络：典型例子是令牌环局域网。&lt;/li&gt;
&lt;li&gt;网状网络：每个节点至少有两条路径与其他节点相连，常用于广域网。优点是可靠性高，缺点是控制复杂、线路成本高。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E6%8B%93%E6%89%91%E7%BD%91%E7%BB%9C.png&#34;
	width=&#34;1386&#34;
	height=&#34;308&#34;
	srcset=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E6%8B%93%E6%89%91%E7%BD%91%E7%BB%9C_hu_2e5744d571e60a2f.png 480w, https://deathofbrain.github.io/p/network-key-points/images/%E6%8B%93%E6%89%91%E7%BD%91%E7%BB%9C_hu_775c8e69fdfc46b7.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;四种拓扑网络&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;450&#34;
		data-flex-basis=&#34;1080px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用者：公用网、专用网&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传输介质：有线网络、无线网络。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;性能指标&#34;&gt;🌟性能指标
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;这个不会就真埋了吧&lt;/p&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;速率：节点在数字信道上传送数据的速率，也称&lt;em&gt;数据传输速率&lt;/em&gt;、&lt;em&gt;数据率&lt;/em&gt;或&lt;em&gt;比特率&lt;/em&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单位：&lt;code&gt;b/s&lt;/code&gt;或&lt;code&gt;bit/s&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数据率较高时，可用&lt;code&gt;Kb/s&lt;/code&gt;、&lt;code&gt;Mb/s&lt;/code&gt;、&lt;code&gt;Gb/s&lt;/code&gt;等。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;放到常见情形，可以对应下载速率或上传速率&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在计网中，K=10^3，M=10^6，G=10^9，幂数每一级+3&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;带宽：在计网中，表示网络等通信线路所能传送数据的能力。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;也就是&lt;strong&gt;最高&lt;/strong&gt;数据传输速率&lt;/p&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;单位：&lt;code&gt;bit/s&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;吞吐量：单位时间内通过某个网络（或信道、接口）的实际数据量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常用于对实际网络的测量，以便获知有多少数据量能够通过网络。&lt;/li&gt;
&lt;li&gt;一条由多端链路组成的信道，其带宽取决于&lt;strong&gt;带宽最小&lt;/strong&gt;的那段链路。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;🌟时延：指数据从网络的一段传送到另一段所需的总时间。由四部分组成：&lt;strong&gt;发送时延&lt;/strong&gt;、&lt;strong&gt;传播时延&lt;/strong&gt;、&lt;strong&gt;处理时延&lt;/strong&gt;和&lt;strong&gt;排队时延&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送时延：又称&lt;strong&gt;传输时延&lt;/strong&gt;，节点将分组的所有比特推向链路所花的时间。
&lt;blockquote&gt;
&lt;p&gt;即从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所花的时间。&lt;/p&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;公式：&lt;code&gt;发送时延 = 分组长度 / 发送速率&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;传播时延：电磁波在信道中传播一定距离所花时间，即一个比特从&lt;strong&gt;链路的一端&lt;/strong&gt;到&lt;strong&gt;另一段&lt;/strong&gt;所需时间。
&lt;ul&gt;
&lt;li&gt;公式：&lt;code&gt;传播时延 = 信道长度 / 电磁波在信道上的传播速率&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;传输时延和传播时延一定要区分开，不然没分了&lt;/p&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;处理时延：分组在交换节点为存储转发而进行的一些必要处理所花的时间。&lt;/li&gt;
&lt;li&gt;排队时延：分组在路由器的输入队列或输出队列中排队等待所花时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;处理时延与排队时延一般忽略不计，或者题目直接给出时间。
因此，&lt;code&gt;总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时延带宽积：指发送端发送的第一个比特即将到达终点时，发送端已经发送了多少比特。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;时延带宽积 = 传播时延 x 信道带宽&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;想象成圆柱形管道，长度为传播时延，横截面积表示链路带宽，则时延带宽积表示&lt;strong&gt;该管道可以容纳的比特数量&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E9%93%BE%E8%B7%AF%E7%AE%A1%E9%81%93.png&#34;
	width=&#34;872&#34;
	height=&#34;212&#34;
	srcset=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E9%93%BE%E8%B7%AF%E7%AE%A1%E9%81%93_hu_c57d9d92aa3b7754.png 480w, https://deathofbrain.github.io/p/network-key-points/images/%E9%93%BE%E8%B7%AF%E7%AE%A1%E9%81%93_hu_f04528a20c3241eb.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;管道&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;411&#34;
		data-flex-basis=&#34;987px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;🌟往返时延（&lt;strong&gt;RTT&lt;/strong&gt;）：指从发送端发出一个短分组，到发送端收到&lt;strong&gt;来自接收端的确认&lt;/strong&gt;（接收端收到数据后立刻发送确认）总共经历的时间。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;RTT包括各中间节点的处理时延、排队时延以及转发数据时的发送时延。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://deathofbrain.github.io/p/network-key-points/images/RTT.png&#34;
	width=&#34;1969&#34;
	height=&#34;1141&#34;
	srcset=&#34;https://deathofbrain.github.io/p/network-key-points/images/RTT_hu_22cbac0eb0121898.png 480w, https://deathofbrain.github.io/p/network-key-points/images/RTT_hu_ece94b1afc84e8c3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;RTT&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;172&#34;
		data-flex-basis=&#34;414px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信道利用率：指出信道有数据通过时间占总时间的百分比&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;信道利用率 = 有数据通过时间 / （有数据通过时间 + 无数据通过时间）&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;信道利用率&lt;strong&gt;并非越高越好&lt;/strong&gt;，太低会浪费资源，太高会&lt;strong&gt;造成拥堵&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;体系结构分层模型&#34;&gt;🌟体系结构、分层模型
&lt;/h3&gt;&lt;h4 id=&#34;概念-1&#34;&gt;概念
&lt;/h4&gt;&lt;p&gt;计算机网络的各层及其协议的集合称为网络的&lt;strong&gt;体系结构&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;换言之，计算机网络的体系结构就是这个计算机网络及其所应完成的功能的精确定义。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;要注意，这些功能如何实现，是体系结构的&lt;strong&gt;实现&lt;/strong&gt;问题。体系结构是&lt;strong&gt;抽象&lt;/strong&gt;的，它不在乎如何去实现，实现问题是&lt;strong&gt;具体&lt;/strong&gt;的。&lt;/p&gt;
&lt;h4 id=&#34;分层&#34;&gt;分层
&lt;/h4&gt;&lt;p&gt;计网体系结构通常都是可分层的，它将复杂的大系统分成若干较容易实现的层次。&lt;/p&gt;
&lt;p&gt;分层的基本原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每层都实现一种相对独立的功能&lt;/li&gt;
&lt;li&gt;各层之间接口清晰、易于理解、相互交流尽可能少&lt;/li&gt;
&lt;li&gt;各层功能的精确定义&lt;strong&gt;独立于&lt;/strong&gt;具体实现&lt;/li&gt;
&lt;li&gt;保持下层对上层的独立性，&lt;strong&gt;上层单向使用下层提供的服务&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;整个分层结构应能促进标准化&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;实体&#34;&gt;实体
&lt;/h4&gt;&lt;p&gt;实体，指任何可发送或接收信息的硬件或软件进程，通常是某个特定的软件模块。&lt;/p&gt;
&lt;p&gt;在网络分层结构中，第n层的活动元素通常称为&lt;strong&gt;第n层实体&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不同终端的同一层称为&lt;strong&gt;对等层&lt;/strong&gt;，同一层的实体称为&lt;strong&gt;对等实体&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;🌟&lt;strong&gt;第n层向第n+1层提供服务，这些服务也包括第n层及以下各层提供的服务。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;就这一句话值得去背&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;第n层的实体称为&lt;strong&gt;服务提供者&lt;/strong&gt;，服务提供者上一层的实体称为&lt;strong&gt;服务用户&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;数据单元&#34;&gt;数据单元
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;协议数据单元（&lt;strong&gt;PDU&lt;/strong&gt;）：&lt;strong&gt;对等层&lt;/strong&gt;之间传送的数据单位，第n层的PDU称为n-PDU
&lt;ul&gt;
&lt;li&gt;各层的PDU都分为服务数据单元和协议控制信息两个部分&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;服务数据单元（&lt;strong&gt;SDU&lt;/strong&gt;）：&lt;strong&gt;层与层&lt;/strong&gt;之间交换的数据单位，第n层的SDU称为n-SDU&lt;/li&gt;
&lt;li&gt;协议控制信息（&lt;strong&gt;PCI&lt;/strong&gt;）：&lt;strong&gt;控制协议操作&lt;/strong&gt;的信息。第n层的PCI称为n-PCI&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体三者的关系如图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://deathofbrain.github.io/p/network-key-points/images/pdu_sdu_pci.png&#34;
	width=&#34;195&#34;
	height=&#34;115&#34;
	srcset=&#34;https://deathofbrain.github.io/p/network-key-points/images/pdu_sdu_pci_hu_8f0ada956b3bd3b0.png 480w, https://deathofbrain.github.io/p/network-key-points/images/pdu_sdu_pci_hu_8de95bf00d5ea091.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;三种数据单元关系&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;169&#34;
		data-flex-basis=&#34;406px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;各层之间数据单元的联系如图。请注意，数据链路层（第2层）的PDU中有两个PCI。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E5%90%84%E5%B1%82%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83%E7%9A%84%E8%81%94%E7%B3%BB.png&#34;
	width=&#34;1570&#34;
	height=&#34;946&#34;
	srcset=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E5%90%84%E5%B1%82%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83%E7%9A%84%E8%81%94%E7%B3%BB_hu_631addc6284644e2.png 480w, https://deathofbrain.github.io/p/network-key-points/images/%E5%90%84%E5%B1%82%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83%E7%9A%84%E8%81%94%E7%B3%BB_hu_6feed396f1432bb.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;各层数据单元的关系&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;165&#34;
		data-flex-basis=&#34;398px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;横向上来看，各层之间在逻辑上有一个直接信道，表现为能直接将该层PDU传送给对方&lt;/p&gt;
&lt;p&gt;纵向上来看，发送端高层PDU作为底层SDU不断封装，到接收端自底向上不断解包。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h4 id=&#34;层次结构的含义&#34;&gt;层次结构的含义
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;第n层实体不仅要使用下面一层（n-1层）的&lt;strong&gt;服务&lt;/strong&gt;来实现自身定义的功能，还要向上面一层（n+1层）提供本层的服务，并且该服务是&lt;strong&gt;第n层及其下面各层提供的服务总和&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;最低层（物理层）&lt;strong&gt;只提供服务&lt;/strong&gt;，是整个层次结构的基础&lt;/li&gt;
&lt;li&gt;最高层（应用层）&lt;strong&gt;向用户提供服务&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;上一层只能通过&lt;strong&gt;相邻层间接口&lt;/strong&gt;使用下一层的服务，而不能调用其他层的服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;协议接口服务的概念&#34;&gt;🌟协议、接口、服务的概念
&lt;/h3&gt;&lt;h4 id=&#34;协议&#34;&gt;🌟协议
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;这个不会可以埋了&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;网络协议：为了在网络中进行数据交换而建立的通信规则、标准或约定，是控制在&lt;strong&gt;对等实体&lt;/strong&gt;之间进行通信规则的集合，是&lt;strong&gt;水平&lt;/strong&gt;的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;自然，不对等实体之间是没有协议的。就像A的网络层和B的传输层之间就没有协议这一说法。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;🌟&lt;strong&gt;协议三要素：语法、语义、时序&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语法：数据与控制信息的格式&lt;/li&gt;
&lt;li&gt;语义：定义需要发出什么控制信息、完成什么动作、做出什么回答&lt;/li&gt;
&lt;li&gt;时序：事件实现顺序的详细说明，即执行各种操作的条件、时序关系等&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;接口&#34;&gt;接口
&lt;/h4&gt;&lt;p&gt;同一节点内 相邻两层间 实体交换信息的逻辑接口称为&lt;strong&gt;服务访问点（SAP）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当然，每一层只能在紧邻层之间定义接口，而不能跨层定义接口。&lt;/p&gt;
&lt;p&gt;请注意：&lt;strong&gt;服务是通过SAP提供给上层使用的&lt;/strong&gt;，也就是说，第n层的SAP就是第n+1层可以访问第n层服务的地方。&lt;/p&gt;
&lt;h4 id=&#34;服务&#34;&gt;服务
&lt;/h4&gt;&lt;p&gt;服务是指下层为紧邻上层提供的功能调用，是&lt;strong&gt;垂直&lt;/strong&gt;的。&lt;/p&gt;
&lt;p&gt;对等实体在协议的控制下，使得本层能为上层提供服务，但要实现本层协议，还需要使用下层提供的服务。&lt;/p&gt;
&lt;p&gt;注意：并非在一层内完成的全部功能都称为服务，只有那些能够被高一层实体&lt;strong&gt;调用&lt;/strong&gt;的功能才称为服务。&lt;/p&gt;
&lt;h4 id=&#34;协议与服务区别&#34;&gt;协议与服务区别
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;协议是&lt;strong&gt;水平&lt;/strong&gt;的，服务是&lt;strong&gt;垂直&lt;/strong&gt;的&lt;/li&gt;
&lt;li&gt;只有本层协议的实现才能保证向上一层提供服务&lt;/li&gt;
&lt;li&gt;下面的协议对上层的服务用户是&lt;strong&gt;透明&lt;/strong&gt;的，仅提供服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;协议接口服务三者之间的关系&#34;&gt;协议、接口、服务三者之间的关系
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E5%8D%8F%E8%AE%AE%E6%8E%A5%E5%8F%A3%E6%9C%8D%E5%8A%A1.png&#34;
	width=&#34;1160&#34;
	height=&#34;390&#34;
	srcset=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E5%8D%8F%E8%AE%AE%E6%8E%A5%E5%8F%A3%E6%9C%8D%E5%8A%A1_hu_1678192e015098b6.png 480w, https://deathofbrain.github.io/p/network-key-points/images/%E5%8D%8F%E8%AE%AE%E6%8E%A5%E5%8F%A3%E6%9C%8D%E5%8A%A1_hu_a4792bfa9b1ecd13.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;三者关系&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;297&#34;
		data-flex-basis=&#34;713px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;计网提供的服务&#34;&gt;计网提供的服务
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;面向连接服务与无连接服务
&lt;ul&gt;
&lt;li&gt;面向连接服务：通信双方&lt;strong&gt;必须建立连接（TCP由传输层负责）&lt;/strong&gt;，分配资源，传输结束后释放连接和占用资源。
&lt;ul&gt;
&lt;li&gt;代表协议：&lt;strong&gt;TCP（传输层）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;无连接服务：通信双方&lt;strong&gt;不需要&lt;/strong&gt;建立连接，需要发送数据可直接发送，将每个带有目的地址的包传送到线路上，由系统选定路线进行传输
&lt;ul&gt;
&lt;li&gt;常被描述为&lt;strong&gt;尽最大努力交付&lt;/strong&gt;，是不可靠的服务&lt;/li&gt;
&lt;li&gt;代表协议：&lt;strong&gt;IP（网络层）&lt;/strong&gt;、&lt;strong&gt;UDP（传输层）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可靠服务与不可靠服务
&lt;ul&gt;
&lt;li&gt;可靠服务：网络具有纠错检错、应答机制，保证数据正确、可靠地传送到目的地。&lt;/li&gt;
&lt;li&gt;不可靠服务：网络&lt;strong&gt;尽量&lt;/strong&gt;让数据正确、可靠地传送到目的地，尽力而为。
&lt;ul&gt;
&lt;li&gt;可以由更高层来保障网络的正确与可靠&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;IP就是不可靠的网络层协议，但是TCP作为传输层的协议，可以借助这个不可靠的服务，向上层提供可靠的服务。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有应答服务和无应答服务
&lt;ul&gt;
&lt;li&gt;有应答服务：接收方在收到数据时，向发送方发送应答
&lt;ul&gt;
&lt;li&gt;应答可以是肯定应答，也可以是否定应答。接收的数据有错误时，即发送否定应答，以此让发送者重发&lt;/li&gt;
&lt;li&gt;这个应答由系统内部自动实现，而不需要用户实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;无应答服务：接收方在收到数据时，不发送应答
&lt;ul&gt;
&lt;li&gt;若需要应答，则需要高层实现&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;WWW服务，客户端收到服务器发送的页面文件后，不给出回答&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;isoosi模型和tcpip模型&#34;&gt;🌟ISO/OSI模型和TCP/IP模型
&lt;/h3&gt;&lt;h4 id=&#34;osi模型&#34;&gt;OSI模型
&lt;/h4&gt;&lt;p&gt;ISO提出的网络体系结构模型，称为OSI模型，有七层，自底向上依次为：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;七层都有什么，要背下来，同样，接下来的四层TCP/IP模型也要背下来，当然还有特供五层折中模型更要背下来&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://deathofbrain.github.io/p/network-key-points/images/OSI.png&#34;
	width=&#34;1642&#34;
	height=&#34;694&#34;
	srcset=&#34;https://deathofbrain.github.io/p/network-key-points/images/OSI_hu_21bf7207732a1fc3.png 480w, https://deathofbrain.github.io/p/network-key-points/images/OSI_hu_89b26122dc994c9a.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;OSI模型&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;236&#34;
		data-flex-basis=&#34;567px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;接下来的各层，在后续章节基本都要讲述，这里只是简单介绍&lt;/p&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;物理层&lt;/p&gt;
&lt;p&gt;物理层的传输单位是&lt;strong&gt;比特&lt;/strong&gt;，功能是在物理介质上为数据端设备&lt;strong&gt;透明&lt;/strong&gt;地传输原始比特流。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通信链路与通信节点的连接需要一些电路接口，物理层规定了这些接口的一些参数，如机械形状尺寸、引脚数量和排列等。&lt;/li&gt;
&lt;li&gt;物理层规定了通信链路上所传输的信号的意义和电气特征。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;物理介质并不在物理层协议之中&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据链路层&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据链路层的传输单位是&lt;strong&gt;帧&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;两台主机之间的数据传输总是在一段一段的链路上进行的，使用专门的链路层协议。
&lt;blockquote&gt;
&lt;p&gt;加强物理层功能，将物理层提供的可能出错的物理连接改造成逻辑上无差错的数据链路。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;数据链路层将网络层交付的IP分组封装成帧，可靠地传输到相邻节点的网络层，实现节点间&lt;strong&gt;差错控制&lt;/strong&gt;、&lt;strong&gt;流量控制&lt;/strong&gt;的功能。
&lt;blockquote&gt;
&lt;p&gt;差错控制：物理层传输时，可能会发生比特位翻转错误等。差错控制可以检测出这些差错（CRC算法等），将收到的错误信息丢弃。&lt;/p&gt;
&lt;p&gt;流量控制：假设A的网速是千兆，B的网速是百兆，若不加以控制，则B会丢失许多来不及接收的数据，造成传输线路效率下降。流量控制可以协调两个节点的速率，使A与B之间的发送速率对上。当然，最终线路肯定是取决于速率低的一方。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;广播式网络（例如Wi-Fi）在这一层还要处理诸如控制对共享信道的访问等新的问题。
&lt;blockquote&gt;
&lt;p&gt;后面有讲的，哈哈，还考呢&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网络层&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网络层的传输单位是&lt;strong&gt;数据报&lt;/strong&gt;。这层关心的是通信子网的运行控制，主要任务是将网络层的PDU（分组）从源主机到目的主机，为分组交换网上不同主机提供通信服务。&lt;/li&gt;
&lt;li&gt;关键问题：&lt;strong&gt;对分组进行路由选择&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;实现功能：流量控制、拥塞控制、差错控制、网际互联等。
&lt;blockquote&gt;
&lt;p&gt;当有多条可选择的路由线路时，网络层会根据网络情况，利用相应路由算法计算出一条合适的路径，使这个分组可以顺利地到达目标节点，如图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E6%9F%90%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E5%9B%BE.png&#34;
	width=&#34;650&#34;
	height=&#34;304&#34;
	srcset=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E6%9F%90%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E5%9B%BE_hu_26e9115f74d0fa4f.png 480w, https://deathofbrain.github.io/p/network-key-points/images/%E6%9F%90%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E5%9B%BE_hu_1c11027b3bf3d857.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;某网络结构图&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;213&#34;
		data-flex-basis=&#34;513px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;拥塞控制：当上图的节点都来不及接收分组，会导致大量分组丢失，网络处于拥塞状态。此时网络层要采取措施来缓解这种拥塞，这就是拥塞控制。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;在OSI中，网络层提供&lt;strong&gt;有连接可靠的虚电路服务&lt;/strong&gt;，也提供&lt;strong&gt;无连接不可靠的数据报服务&lt;/strong&gt;。
&lt;blockquote&gt;
&lt;p&gt;请注意，在TCP/IP模型中，网络层仅提供&lt;strong&gt;无连接不可靠的数据报服务&lt;/strong&gt;。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传输层&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;负责相互通信的主机中两个&lt;strong&gt;进程&lt;/strong&gt;之间的通信，提供的是&lt;strong&gt;端到端&lt;/strong&gt;服务，如流量控制、差错控制、连接建立与释放、可靠传输管理等服务。&lt;/li&gt;
&lt;li&gt;在OSI模型中，传输层&lt;strong&gt;只提供有连接可靠的服务&lt;/strong&gt;。
&lt;blockquote&gt;
&lt;p&gt;同样，在TCP/IP模型中，传输层提供有连接可靠服务（TCP），也提供无连接不可靠服务（UDP）。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;点到点：主机和主机之间。&lt;/li&gt;
&lt;li&gt;端到端：运行在不同主机之间&lt;strong&gt;两个进程&lt;/strong&gt;之间的通信，一个进程用&lt;strong&gt;一个端口&lt;/strong&gt;来标识。&lt;/li&gt;
&lt;li&gt;通过传输层的屏蔽，高层用户看不到通信子网的交替和变化。因为一台主机可同时运行多个进程，故传送层具有&lt;strong&gt;复用和分用&lt;/strong&gt;的功能。
&lt;ul&gt;
&lt;li&gt;复用：多个应用层进程可同时运行多个进程&lt;/li&gt;
&lt;li&gt;分用：传送层将收到的信息分别交付给应用层中对应的进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;会话层&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作用：为表示层实体或用户进程建立连接，在连接上有序传输数据。&lt;/li&gt;
&lt;li&gt;负责管理主机间会话进程，包括建立、管理、终止进程间会话。&lt;/li&gt;
&lt;li&gt;🌟该层包含一种&lt;strong&gt;检查点&lt;/strong&gt;机制，当断网又恢复时，通信会话会从检查点&lt;strong&gt;继续通信&lt;/strong&gt;，也就是断点下载的原理。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表示层&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主要处理不同主机中交换信息的&lt;strong&gt;表示方式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;🌟不同机器的编码和表示方法可能不同，要做到互相交换，就要由表示层&lt;strong&gt;采用抽象方法&lt;/strong&gt;定义数据结构，采用&lt;strong&gt;标准编码形式&lt;/strong&gt;传输，使其能相互交换信息。&lt;/li&gt;
&lt;li&gt;🌟&lt;strong&gt;数据压缩&lt;/strong&gt;、&lt;strong&gt;加密解密&lt;/strong&gt;也是表示层的功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;全书的会话层和表示层就这三个考点&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应用层&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是OSI模型的最高层，是用户与网络的接口。&lt;/li&gt;
&lt;li&gt;采用不同应用协议，满足不同类型的应用要求，因此这一层最复杂，协议也最多。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;tcpip模型&#34;&gt;TCP/IP模型
&lt;/h4&gt;&lt;p&gt;自底向上分为&lt;strong&gt;网络接口层&lt;/strong&gt;、&lt;strong&gt;网际层&lt;/strong&gt;、&lt;strong&gt;传输层&lt;/strong&gt;、&lt;strong&gt;应用层&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;其中，网络接口层对应OSI中的物理层和数据链路层，应用层对应OSI中的会话层、表示层和应用层。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://deathofbrain.github.io/p/network-key-points/images/TCPIP%E6%A8%A1%E5%9E%8B.png&#34;
	width=&#34;934&#34;
	height=&#34;522&#34;
	srcset=&#34;https://deathofbrain.github.io/p/network-key-points/images/TCPIP%E6%A8%A1%E5%9E%8B_hu_57457a11c8573536.png 480w, https://deathofbrain.github.io/p/network-key-points/images/TCPIP%E6%A8%A1%E5%9E%8B_hu_29544304d5d88a8a.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;TCP/IP模型&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;178&#34;
		data-flex-basis=&#34;429px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网络接口层
&lt;ul&gt;
&lt;li&gt;作用：从主机或节点接收IP分组，并发送到指定物理网络上。&lt;/li&gt;
&lt;li&gt;TCP/IP没有指出网络接口层的功能和协议，仅指出主机必须使用某种协议与网络连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;网际层
&lt;ul&gt;
&lt;li&gt;TCP/IP模型的关键部分&lt;/li&gt;
&lt;li&gt;与OSI模型中网络层非常相似，将分组发到网络，并选择合适路由。&lt;/li&gt;
&lt;li&gt;传输单位：&lt;strong&gt;IP数据报&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;仅提供无连接不可靠的服务（IPv4、IPv6）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;传输层
&lt;ul&gt;
&lt;li&gt;与OSI中传输层类似&lt;/li&gt;
&lt;li&gt;提供两种服务：&lt;strong&gt;TCP&lt;/strong&gt;、&lt;strong&gt;UDP&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;这一点与OSI不同，OSI传输层仅提供可靠服务，TCP/IP两种都提供&lt;/p&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;TCP是&lt;strong&gt;面向连接的可靠服务&lt;/strong&gt;，要首先建立连接，传输单位是&lt;strong&gt;报文段&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;UDP是&lt;strong&gt;无连接的不可靠服务&lt;/strong&gt;，尽最大努力交付，传输单位是&lt;strong&gt;数据报&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;应用层
&lt;ul&gt;
&lt;li&gt;包含所有的高层协议（Telnet、FTP、DNS、SMTP、HTTP……）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;两种模型比较&#34;&gt;🌟两种模型比较
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%9E%8B%E6%AF%94%E8%BE%83.png&#34;
	width=&#34;1122&#34;
	height=&#34;502&#34;
	srcset=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%9E%8B%E6%AF%94%E8%BE%83_hu_64eee923f26d59fe.png 480w, https://deathofbrain.github.io/p/network-key-points/images/%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%9E%8B%E6%AF%94%E8%BE%83_hu_4ac2a8b6744fb6d1.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;两种模型比较&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;223&#34;
		data-flex-basis=&#34;536px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相同点
&lt;ul&gt;
&lt;li&gt;都采用分层的体系结构，分层功能大体相似&lt;/li&gt;
&lt;li&gt;基于独立的协议栈的概念&lt;/li&gt;
&lt;li&gt;都可解决异构网络的互联&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;🌟不同点
&lt;ul&gt;
&lt;li&gt;OSI精确定义了服务、协议和接口，TCP/IP没有做到&lt;/li&gt;
&lt;li&gt;层数不一样，OSI更精细&lt;/li&gt;
&lt;li&gt;OSI先有模型，后有协议规范，TCP/IP正好反过来，因此TCP/IP模型不适合其它非TCP/IP网络。&lt;/li&gt;
&lt;li&gt;🌟OSI模型在网络层支持&lt;strong&gt;无连接&lt;/strong&gt;和&lt;strong&gt;面向连接&lt;/strong&gt;的通信，但在传输层仅有&lt;strong&gt;面向连接&lt;/strong&gt;的通信&lt;/li&gt;
&lt;li&gt;🌟TCP/IP模型认为可靠性是端到端的问题，因此在网际层仅提供&lt;strong&gt;无连接&lt;/strong&gt;通信，但传输层支持&lt;strong&gt;面向连接&lt;/strong&gt;和&lt;strong&gt;无连接&lt;/strong&gt;通信。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么隆重介绍：特供学习用折中方案：五层协议体系结构模型&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png&#34;
	width=&#34;1122&#34;
	height=&#34;502&#34;
	srcset=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84_hu_80f2c2cf5fb62e42.png 480w, https://deathofbrain.github.io/p/network-key-points/images/%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84_hu_4b44750cc2631853.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;五层协议体系结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;223&#34;
		data-flex-basis=&#34;536px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其实就是把OSI的物理层和数据链路层搬过来，上面全是TCP/IP的层&lt;/p&gt;&lt;/blockquote&gt;
&lt;h4 id=&#34;协议栈数据传输过程&#34;&gt;协议栈数据传输过程
&lt;/h4&gt;&lt;p&gt;一句话：上层PDU被每一层封装，传输过去再自底向上解包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E5%8D%8F%E8%AE%AE%E6%A0%88%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.png&#34;
	width=&#34;1376&#34;
	height=&#34;660&#34;
	srcset=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E5%8D%8F%E8%AE%AE%E6%A0%88%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B_hu_5a8181a99daaf705.png 480w, https://deathofbrain.github.io/p/network-key-points/images/%E5%8D%8F%E8%AE%AE%E6%A0%88%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B_hu_4307917b8417e00c.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;协议栈通信过程&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;208&#34;
		data-flex-basis=&#34;500px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;具体的内容参考PDU那一部分。&lt;/p&gt;
&lt;h2 id=&#34;物理层&#34;&gt;物理层
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;主要考点：码元换算，香农定理，奈奎斯特定理，几种常见数字数据编码。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;通信基础&#34;&gt;通信基础
&lt;/h3&gt;&lt;h4 id=&#34;基本概念&#34;&gt;基本概念
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;数据、信号、码元
&lt;ul&gt;
&lt;li&gt;数据：传送信息的实体&lt;/li&gt;
&lt;li&gt;信号：数据的电气或电磁表现，是数据在传输过程中的存在形式
&lt;ul&gt;
&lt;li&gt;模拟数据（模拟信号）的取值是连续的，数字数据（数字信号）的取值是离散的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;🌟在通信系统中，常用一个固定时长的信号波形表示一个k进制数，这个时长内的信号称为&lt;strong&gt;码元&lt;/strong&gt;（也叫&lt;strong&gt;k进制码元&lt;/strong&gt;）
&lt;ul&gt;
&lt;li&gt;这个时长也叫码元宽度（信号周期）&lt;/li&gt;
&lt;li&gt;一码元可携带若干比特的信息量，体现在一个信号周期内出现k种信号，则该信号对应一个k进制数（$log_2(k)$bit）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;信源、信道、信宿
&lt;ul&gt;
&lt;li&gt;信源：发送数据的源头&lt;/li&gt;
&lt;li&gt;信宿：接收数据的终点&lt;/li&gt;
&lt;li&gt;信道：信号的传输介质
&lt;ul&gt;
&lt;li&gt;按传输信号形式区分：模拟信道、数字信道&lt;/li&gt;
&lt;li&gt;按传输介质区分：无线信道、有线信道
&lt;img src=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E5%8D%95%E5%90%91%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F.png&#34;
	width=&#34;1376&#34;
	height=&#34;254&#34;
	srcset=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E5%8D%95%E5%90%91%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F_hu_633118d1cfeff399.png 480w, https://deathofbrain.github.io/p/network-key-points/images/%E5%8D%95%E5%90%91%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F_hu_e7dfc0d79ab4f4b3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;单向通信系统&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;541&#34;
		data-flex-basis=&#34;1300px&#34;
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;图中的噪声源是信道上的噪声及分散在通信系统其它各处噪声的集中表示。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;传输信号区分
&lt;ul&gt;
&lt;li&gt;基带传输：在信道中直接传送基带信号&lt;/li&gt;
&lt;li&gt;宽带传输：将基带信号进行调制后，形成频分复用模拟信号，然后在信道上运输&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;基带信号：由信源发出的未经过调制的原始电信号&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;传输方式区分
&lt;ul&gt;
&lt;li&gt;串行传输：逐个比特按序进行传输，适合长距离通信&lt;/li&gt;
&lt;li&gt;并行传输：若干比特通过多个通信信道同时传输，适合短距离通信（CPU与主存）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;交互方式区分
&lt;ul&gt;
&lt;li&gt;单向通信：只有一个方向的通信，如广播等&lt;/li&gt;
&lt;li&gt;半双工通信：通信双方都可发送或接收，但任何一方都不能同时发送和接收消息（对讲机通话）&lt;/li&gt;
&lt;li&gt;全双工通信：通信双方都可同时发送或接收消息（以太网）&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;单向通信只需一个信道；半双工和全双工都需要两个信道，每个方向一个信道。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;速率、波特、带宽
&lt;ul&gt;
&lt;li&gt;速率：数据传输速率，有两种描述形式
&lt;ul&gt;
&lt;li&gt;码元传输速率：又叫&lt;strong&gt;波特率&lt;/strong&gt;或调制速率，单位为&lt;strong&gt;波特（Baud）&lt;/strong&gt;。码元速率与进制&lt;strong&gt;无关&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;信息传输速率：又叫&lt;strong&gt;比特率&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;波特和比特完全不同，但波特率和比特率在数量上有关系。&lt;/p&gt;
&lt;p&gt;若一个码元携带n比特信息，则&lt;code&gt;M Baud = Mn b/s&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;带宽（频率带宽）表示某个信道所能传输信号的频率范围，即最高频率与最低频率之差。单位为赫兹（Hz）。
&lt;blockquote&gt;
&lt;p&gt;在计网中，带宽更常见用来描述网络通信线路所能传输数据的能力，即最高数据率，此时带宽的单位为&lt;code&gt;b/s&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;信道的极限容量&#34;&gt;🌟信道的极限容量
&lt;/h4&gt;&lt;p&gt;任何信道都有噪音，虽然接收端能够从失真信号波形中识别出原来信号，但波特率越高，或信号传输距离越远，或传输介质质量越差，接收端波形失真越严重，直到无法读取。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;奈奎斯特定理：理想信道的最大&lt;strong&gt;波特率&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;🌟在&lt;strong&gt;理想低通信道&lt;/strong&gt;中（没有噪音、带宽有限），为了避免码间串扰，&lt;strong&gt;极限波特率&lt;/strong&gt;为&lt;strong&gt;2W波特&lt;/strong&gt;，其中&lt;code&gt;W&lt;/code&gt;是信道的频率带宽（单位Hz）
&lt;blockquote&gt;
&lt;p&gt;码间串扰：具体的信道所能通过的频率范围往往是有限的，信号中许多高频分量往往不能通过信道，否则在传输过程中就会衰减，导致接收端收到的信号波形失去码元之间的清晰界限，即发生码间串扰。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;若此时有&lt;code&gt;V&lt;/code&gt;种不同码元，则&lt;strong&gt;极限数据传输速率&lt;/strong&gt;为$2Wlog_2V$&lt;code&gt;b/s&lt;/code&gt;
&lt;blockquote&gt;
&lt;p&gt;注意单位区分&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;结论：
&lt;ol&gt;
&lt;li&gt;在任何信道中，码元传输速率&lt;strong&gt;有上限&lt;/strong&gt;，若超过这个上限，则会出现严重的码间串扰。&lt;/li&gt;
&lt;li&gt;信道带宽越大，传输码元能力越强&lt;/li&gt;
&lt;li&gt;奈奎斯特定理给出了波特率的限制，但&lt;strong&gt;没有限制码元可以携带多少比特&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;若要提高数据传输速率，就要设法使每个码元携带更多比特信息量，此时需要采用多元制的调制方法。&lt;/p&gt;
&lt;p&gt;事实上，香农定理表明，一个码元可以携带的比特数也是有限的，只是奈奎斯特定理没有体现出来。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;香农定理：&lt;strong&gt;带宽受限，且有高斯噪声干扰的信道&lt;/strong&gt;的极限&lt;strong&gt;数据传输速率&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;若&lt;code&gt;W&lt;/code&gt;为信道频率带宽（Hz），&lt;code&gt;S&lt;/code&gt;为信道内所传输信号的平均功率，&lt;code&gt;N&lt;/code&gt;为信道内高斯噪声的功率，那么信道的&lt;strong&gt;极限数据传输速率&lt;/strong&gt;为$Wlog_2(1+S/N)$&lt;code&gt;b/s&lt;/code&gt;。
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;S/N&lt;/code&gt;为信噪比，有两种表示方式：无单位与分贝记法（dB）。&lt;/li&gt;
&lt;li&gt;换算：若$n$为无单位信噪比，则分贝记法为$10log_{10}(n)$&lt;code&gt;dB&lt;/code&gt;。香农定理中&lt;code&gt;S/N&lt;/code&gt;采用无单位记法，需要学会互相换算。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;结论：
&lt;ol&gt;
&lt;li&gt;信道的带宽或信道中的信噪比越大，极限传输速率越高&lt;/li&gt;
&lt;li&gt;对一定带宽与信噪比，信息传输速率的上限是固定的&lt;/li&gt;
&lt;li&gt;只要信息传输速率低于信道极限传输速率，就能找到某种方法实现无差错的传输。&lt;/li&gt;
&lt;li&gt;香农定理得出的是极限信息传输速率，实际信道能达到的传输速率要比它低不少。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;二者对比
&lt;ul&gt;
&lt;li&gt;奈奎斯特定理只考虑了带宽与极限码元传输速率之间的关系，而香农定理不仅考虑了带宽，还考虑了信噪比。&lt;/li&gt;
&lt;li&gt;从另一个角度来看，&lt;strong&gt;一个码元可以携带的比特数是有限的&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;⚠️当给定条件要求计算信道最大传输速率时，即使给出信噪比，两个公式也要同时用，并且奈奎斯特定理还要根据码元信号种数换算成极限传输速率，最后两个值比较，&lt;strong&gt;谁最小谁就是极限传输速率&lt;/strong&gt;。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h4 id=&#34;编码与调制&#34;&gt;🌟编码与调制
&lt;/h4&gt;</description>
        </item>
        <item>
        <title>数据结构</title>
        <link>https://deathofbrain.github.io/p/structure-key-points/</link>
        <pubDate>Tue, 24 Dec 2024 00:00:00 +0000</pubDate>
        
        <guid>https://deathofbrain.github.io/p/structure-key-points/</guid>
        <description>&lt;h2 id=&#34;绪论&#34;&gt;绪论
&lt;/h2&gt;&lt;h3 id=&#34;数据结构的基本概念&#34;&gt;数据结构的基本概念
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;逻辑结构&lt;/p&gt;
&lt;p&gt;逻辑结构是指数据对象中&lt;strong&gt;数据元素之间的相互关系&lt;/strong&gt;，即从&lt;strong&gt;逻辑上&lt;/strong&gt;描述数据元素之间的关系。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意与存储结构之间做区分&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;逻辑结构分为&lt;strong&gt;线性结构&lt;/strong&gt;和&lt;strong&gt;非线性结构&lt;/strong&gt;，再细分为&lt;strong&gt;集合结构&lt;/strong&gt;、&lt;strong&gt;线性结构&lt;/strong&gt;、&lt;strong&gt;树形结构&lt;/strong&gt;和&lt;strong&gt;图形结构&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;基本上是判断一个数据结构是属于哪种逻辑结构，所以心中有数就好。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;存储结构&lt;/p&gt;
&lt;p&gt;存储结构则是指数据对象中数据元素之间的&lt;strong&gt;存储关系&lt;/strong&gt;，即从&lt;strong&gt;物理上&lt;/strong&gt;描述数据元素之间的关系。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;逻辑结构是你看到的，存储结构是计算机看到的。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;存储结构分为&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;顺序存储结构&lt;/strong&gt;：逻辑上相邻的元素在物理上也相邻&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;链式存储结构&lt;/strong&gt;：逻辑上相邻的元素在物理上不一定相邻&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;索引存储结构&lt;/strong&gt;：在存储结构中增加附加的索引表&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;散列存储结构&lt;/strong&gt;：根据关键字直接计算出存储地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据的运算
数据的运算是指对数据对象进行的操作，包括&lt;strong&gt;运算的定义&lt;/strong&gt;和&lt;strong&gt;运算的实现&lt;/strong&gt;两个方面。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：运算的定义是针对逻辑结构的（如树的遍历等），运算的实现是针对存储结构的（对树的遍历来说，顺序存储和链式存储算法实现一定不同）。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;数据的逻辑结构独立于存储结构&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图的邻接表和邻接矩阵都可以表示图这种逻辑结构。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在存储数据时，不仅要存储数据元素本身，还要存储数据元素之间的逻辑关系。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;时间复杂度和空间复杂度-&#34;&gt;时间复杂度和空间复杂度 (⭐)
&lt;/h3&gt;&lt;p&gt;每年必考，常见于选择题第一题和算法题第三小问。其中算法题主要是去研究&lt;strong&gt;你写的&lt;/strong&gt;算法的时空复杂度，选择题则是考察&lt;strong&gt;一段代码&lt;/strong&gt;的时空复杂度。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;时空复杂度的加法规则和乘法规则&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;加法规则：$T(n) = O(max(f(n),g(n)))$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;两个算法串行执行时，时间复杂度取最大值&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;func1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Hello World&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// O(n)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Hello World&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// O(n^2)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// func的时间复杂度为O(n^2)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;乘法规则：$T(n) = O(f(n) \times g(n))$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;两个算法嵌套执行时，时间复杂度相乘&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;func2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// O(n)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;func1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// O(n^2)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// O(n) * O(n^2) = O(n^3)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// func2的时间复杂度为O(n^3)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算时间复杂度的通用办法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单层嵌套&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;待续……&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
    </channel>
</rss>
