<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>408汇总 on DeathofBrain的小屋</title>
        <link>https://deathofbrain.github.io/categories/408%E6%B1%87%E6%80%BB/</link>
        <description>Recent content in 408汇总 on DeathofBrain的小屋</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>DeathofBrain</copyright><atom:link href="https://deathofbrain.github.io/categories/408%E6%B1%87%E6%80%BB/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>计算机网络</title>
        <link>https://deathofbrain.github.io/p/network-key-points/</link>
        <pubDate>Fri, 28 Feb 2025 00:00:00 +0000</pubDate>
        
        <guid>https://deathofbrain.github.io/p/network-key-points/</guid>
        <description>&lt;h2 id=&#34;计算机网络体系结构&#34;&gt;计算机网络体系结构
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;本章内容重点：三种交换（计算）、OSI分层、TCP/IP分层（记忆）、各种指标与单位（计算）&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;计算机网络概述&#34;&gt;▲计算机网络概述
&lt;/h3&gt;&lt;h4 id=&#34;概念&#34;&gt;▲概念
&lt;/h4&gt;&lt;p&gt;定义：将地理位置不同，具有独立功能的多台计算机以及外部设备通过通信线路连接起来，实现&lt;strong&gt;资源共享&lt;/strong&gt;和信息传递的操作系统。&lt;/p&gt;
&lt;h4 id=&#34;组成&#34;&gt;组成
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;需要知道哪些东西是哪个部分的就可以了&lt;/p&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;从组成部分看，计算机网络主要由&lt;strong&gt;硬件&lt;/strong&gt;、&lt;strong&gt;软件&lt;/strong&gt;、&lt;strong&gt;协议&lt;/strong&gt;三大部分组成。
&lt;ul&gt;
&lt;li&gt;硬件：由主机、通信链路、交换设备和网卡等组成&lt;/li&gt;
&lt;li&gt;软件：包括email程序、ftp程序等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;协议&lt;/strong&gt;：计算机网络的核心，规定了网络传输数据时所遵循的规范。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;从工作方式看，可分为&lt;strong&gt;边缘部分&lt;/strong&gt;和&lt;strong&gt;核心部分&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;边缘部分：由所有连接到互联网上的供用户直接使用的主机构成，进行通信和资源共享。&lt;/li&gt;
&lt;li&gt;核心部分：大量网络和连接着的路由器组成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;从功能组成看，可分为&lt;strong&gt;通信子网&lt;/strong&gt;和&lt;strong&gt;资源子网&lt;/strong&gt;。
&lt;ul&gt;
&lt;li&gt;通信子网：各种传输介质、通信设备和相应网络协议组成。
&lt;ul&gt;
&lt;li&gt;使网络具有数据传输、交换、控制和存储的能力，实现数据通信。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;资源子网：实现资源共享的设备及其软件的集合
&lt;ul&gt;
&lt;li&gt;向网络用户提供共享其他计算机上的硬件资源、软件资源、数据资源的服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;功能&#34;&gt;功能
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;数据通信&lt;/strong&gt;：最基本和最重要的功能，实现联网计算机之间信息的传输。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;资源共享&lt;/strong&gt;：共享软件、硬件、数据，让网络中资源互通有无。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分布式处理&lt;/strong&gt;：将某个复杂的任务分配给网络中其它计算机系统，提高整个系统的利用率。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提高可靠性&lt;/strong&gt;：网络中的各台计算机可以互为替代机。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;负载均衡&lt;/strong&gt;：将工作任务均衡地分配给网络中各台计算机。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;电路交换报文交换和分组交换&#34;&gt;🌟电路交换、报文交换和分组交换
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;计网计算题重点，可结合到多种题型&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;路由器&lt;/strong&gt;这个&lt;strong&gt;网络层&lt;/strong&gt;设备在网络核心部分起到重要作用。它对收到的分组进行&lt;strong&gt;存储转发&lt;/strong&gt;实现&lt;strong&gt;分组交换&lt;/strong&gt;。分组交换是现代网络最常用的交换方式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从通信资源分配的角度看，交换就是按照某种方式动态地分配传输线路的资源。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;分组交换由电路交换与报文交换发展而来。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;电路交换（典型：电话网）
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;特点：在进行数据传输前，两个用户之间必须先建立一条专用的&lt;strong&gt;物理&lt;/strong&gt;通信路径，且传输过程中，这一路径始终被两个用户独占，直到通信结束被释放。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分为三步：建立连接（开始占用通信资源）、传输数据、释放连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2.png&#34;
	width=&#34;1070&#34;
	height=&#34;300&#34;
	srcset=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2_hu_24dc96a343a3143.png 480w, https://deathofbrain.github.io/p/network-key-points/images/%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2_hu_e500daeb0be2b7b3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;电路交换&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;356&#34;
		data-flex-basis=&#34;856px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;整条电路上任何节点都不进行存储，直接转发，&lt;strong&gt;不存在存储转发所耗费的时间&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这一点需要记住。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优点：通信时延小、有序传输、没有冲突、实时性强。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：建立连接时间长、线路利用率低、灵活性差、难以实现差错控制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;灵活性差：物理通路中，任何一点出现故障，就必须重新建立连接。&lt;/p&gt;
&lt;p&gt;难以实现差错控制：中间节点不具备存储和检验数据的能力，无法发现并纠正错误。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事实上，计算机之间的数据传输往往是突发式的（高频、少量数据），若使用电路交换，那么整个通信链路资源的利用率往往不到10%，甚至只有1%。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;报文交换——分组交换的前身&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据交换的单位是&lt;strong&gt;报文&lt;/strong&gt;。报文由用户数据、源地址和目的地址等信息组成。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;采用&lt;strong&gt;存储转发&lt;/strong&gt;技术，整个报文先传送到相邻的节点，&lt;strong&gt;全部存储&lt;/strong&gt;后查找转发表，转发到下一个节点，如此反复，直到报文到达目的节点。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;全部存储——报文交换被淘汰的原因&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不同于电路交换，每个报文都可单独选择到达目的端的路径。示例图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E6%8A%A5%E6%96%87%E4%BA%A4%E6%8D%A2.png&#34;
	width=&#34;474&#34;
	height=&#34;159&#34;
	srcset=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E6%8A%A5%E6%96%87%E4%BA%A4%E6%8D%A2_hu_be782a12be3cef81.png 480w, https://deathofbrain.github.io/p/network-key-points/images/%E6%8A%A5%E6%96%87%E4%BA%A4%E6%8D%A2_hu_529dea2db951d3c8.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;报文交换&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;298&#34;
		data-flex-basis=&#34;715px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优点：无建立连接时延、灵活分配线路、线路利用率高、支持差错控制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这些也是存储转发本身的优点。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：转发时延高、缓存开销大、错误处理低效。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;交换节点要把报文都存储完才能查找转发表转发到下一节点，若是报文太大，缓存开销也大，并且一旦丢包，重传代价也大。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分组交换，就是在报文交换&lt;strong&gt;存储转发&lt;/strong&gt;的基础上，将报文划分成若干较小&lt;strong&gt;等长&lt;/strong&gt;数据段，每个数据段前面添加一些由控制信息组成的&lt;strong&gt;首部&lt;/strong&gt;，构成&lt;strong&gt;分组（Packet）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E5%88%86%E7%BB%84.png&#34;
	width=&#34;1070&#34;
	height=&#34;384&#34;
	srcset=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E5%88%86%E7%BB%84_hu_fcdb989a9ab245d8.png 480w, https://deathofbrain.github.io/p/network-key-points/images/%E5%88%86%E7%BB%84_hu_a6569516edf2d64d.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;构成分组&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;278&#34;
		data-flex-basis=&#34;668px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;分组交换&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;流程&lt;/p&gt;
&lt;p&gt;源主机发送分组，分组交换网中的交换机收到分组后，先缓存，然后从首部提取目的地址，借由转发表，发送给下一个交换机，周而复始，直到到达目的主机。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本质上和报文交换一样&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优点：存储转发开销小、传输效率高、减少出错概率与代价。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;分组是逐个传输的，可以使后一个分组的存储操作与前一个分组的转发操作并行，形成&lt;strong&gt;流水线&lt;/strong&gt;，后面的图会详细表达。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：存在存储转发时延、需要传输额外信息、可能出现失序、丢失或重复分组的情况。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;失序丢包等问题是借由上层，或使用虚电路服务解决的，先不必深究。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;三种交换方式的比较&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当要连续传输大量的数据，并且传送时间远大于连接建立时间时，采用电路交换更合适。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;然而，现时代，数据的传送时间肯定小于连接建立时间。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从提高整个网络的信道利用率看，报文交换和分组交换更合适&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其中，分组交换比报文交换时延更小，更加灵活，尤其适合突发式数据传送。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;三种传输时序图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E4%BC%A0%E8%BE%93%E6%97%B6%E5%BA%8F%E5%9B%BE.png&#34;
	width=&#34;1156&#34;
	height=&#34;798&#34;
	srcset=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E4%BC%A0%E8%BE%93%E6%97%B6%E5%BA%8F%E5%9B%BE_hu_315c74c69a76b267.png 480w, https://deathofbrain.github.io/p/network-key-points/images/%E4%BC%A0%E8%BE%93%E6%97%B6%E5%BA%8F%E5%9B%BE_hu_27fbf94784fabc84.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;传输时序图&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;144&#34;
		data-flex-basis=&#34;347px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这东西不会画就可以埋了，做计算题必须要画的图&lt;/p&gt;
&lt;p&gt;为什么是斜的：电磁波在信道中传播需要花费时间（即使非常短），这部分时间也叫传播时延。有些题明确指出传播时延忽略不计时，那就必须要画平了。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;分类&#34;&gt;分类
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;记一下拓扑结构就好了&lt;/p&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;分布范围：广域网、城域网、局域网、个人区域网&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传输技术：广播式网络、点对点网络&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拓扑规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;总线型：优点是建网容易、增删节点方便、节省线路；缺点是重负载时通信效率不高，总线任意一处对故障敏感。&lt;/li&gt;
&lt;li&gt;星形网络：优点是便于集中控制和管理；缺点是成本高、中央设备对故障敏感。&lt;/li&gt;
&lt;li&gt;环形网络：典型例子是令牌环局域网。&lt;/li&gt;
&lt;li&gt;网状网络：每个节点至少有两条路径与其他节点相连，常用于广域网。优点是可靠性高，缺点是控制复杂、线路成本高。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E6%8B%93%E6%89%91%E7%BD%91%E7%BB%9C.png&#34;
	width=&#34;1386&#34;
	height=&#34;308&#34;
	srcset=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E6%8B%93%E6%89%91%E7%BD%91%E7%BB%9C_hu_2e5744d571e60a2f.png 480w, https://deathofbrain.github.io/p/network-key-points/images/%E6%8B%93%E6%89%91%E7%BD%91%E7%BB%9C_hu_775c8e69fdfc46b7.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;四种拓扑网络&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;450&#34;
		data-flex-basis=&#34;1080px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用者：公用网、专用网&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传输介质：有线网络、无线网络。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;性能指标&#34;&gt;🌟性能指标
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;这个不会就真埋了吧&lt;/p&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;速率：节点在数字信道上传送数据的速率，也称&lt;em&gt;数据传输速率&lt;/em&gt;、&lt;em&gt;数据率&lt;/em&gt;或&lt;em&gt;比特率&lt;/em&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单位：&lt;code&gt;b/s&lt;/code&gt;或&lt;code&gt;bit/s&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数据率较高时，可用&lt;code&gt;Kb/s&lt;/code&gt;、&lt;code&gt;Mb/s&lt;/code&gt;、&lt;code&gt;Gb/s&lt;/code&gt;等。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;放到常见情形，可以对应下载速率或上传速率&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在计网中，K=10^3，M=10^6，G=10^9，幂数每一级+3&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;带宽：在计网中，表示网络等通信线路所能传送数据的能力。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;也就是&lt;strong&gt;最高&lt;/strong&gt;数据传输速率&lt;/p&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;单位：&lt;code&gt;bit/s&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;吞吐量：单位时间内通过某个网络（或信道、接口）的实际数据量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常用于对实际网络的测量，以便获知有多少数据量能够通过网络。&lt;/li&gt;
&lt;li&gt;一条由多端链路组成的信道，其带宽取决于&lt;strong&gt;带宽最小&lt;/strong&gt;的那段链路。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;🌟时延：指数据从网络的一段传送到另一段所需的总时间。由四部分组成：&lt;strong&gt;发送时延&lt;/strong&gt;、&lt;strong&gt;传播时延&lt;/strong&gt;、&lt;strong&gt;处理时延&lt;/strong&gt;和&lt;strong&gt;排队时延&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送时延：又称&lt;strong&gt;传输时延&lt;/strong&gt;，节点将分组的所有比特推向链路所花的时间。
&lt;blockquote&gt;
&lt;p&gt;即从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所花的时间。&lt;/p&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;公式：&lt;code&gt;发送时延 = 分组长度 / 发送速率&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;传播时延：电磁波在信道中传播一定距离所花时间，即一个比特从&lt;strong&gt;链路的一端&lt;/strong&gt;到&lt;strong&gt;另一段&lt;/strong&gt;所需时间。
&lt;ul&gt;
&lt;li&gt;公式：&lt;code&gt;传播时延 = 信道长度 / 电磁波在信道上的传播速率&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;传输时延和传播时延一定要区分开，不然没分了&lt;/p&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;处理时延：分组在交换节点为存储转发而进行的一些必要处理所花的时间。&lt;/li&gt;
&lt;li&gt;排队时延：分组在路由器的输入队列或输出队列中排队等待所花时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;处理时延与排队时延一般忽略不计，或者题目直接给出时间。
因此，&lt;code&gt;总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时延带宽积：指发送端发送的第一个比特即将到达终点时，发送端已经发送了多少比特。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;时延带宽积 = 传播时延 x 信道带宽&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;想象成圆柱形管道，长度为传播时延，横截面积表示链路带宽，则时延带宽积表示&lt;strong&gt;该管道可以容纳的比特数量&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E9%93%BE%E8%B7%AF%E7%AE%A1%E9%81%93.png&#34;
	width=&#34;872&#34;
	height=&#34;212&#34;
	srcset=&#34;https://deathofbrain.github.io/p/network-key-points/images/%E9%93%BE%E8%B7%AF%E7%AE%A1%E9%81%93_hu_c57d9d92aa3b7754.png 480w, https://deathofbrain.github.io/p/network-key-points/images/%E9%93%BE%E8%B7%AF%E7%AE%A1%E9%81%93_hu_f04528a20c3241eb.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;管道&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;411&#34;
		data-flex-basis=&#34;987px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;🌟往返时延（&lt;strong&gt;RTT&lt;/strong&gt;）：指从发送端发出一个短分组，到发送端收到&lt;strong&gt;来自接收端的确认&lt;/strong&gt;（接收端收到数据后立刻发送确认）总共经历的时间。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;RTT包括各中间节点的处理时延、排队时延以及转发数据时的发送时延。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://deathofbrain.github.io/p/network-key-points/images/RTT.png&#34;
	width=&#34;1969&#34;
	height=&#34;1141&#34;
	srcset=&#34;https://deathofbrain.github.io/p/network-key-points/images/RTT_hu_22cbac0eb0121898.png 480w, https://deathofbrain.github.io/p/network-key-points/images/RTT_hu_ece94b1afc84e8c3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;RTT&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;172&#34;
		data-flex-basis=&#34;414px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信道利用率：指出信道有数据通过时间占总时间的百分比&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;信道利用率 = 有数据通过时间 / （有数据通过时间 + 无数据通过时间）&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;信道利用率&lt;strong&gt;并非越高越好&lt;/strong&gt;，太低会浪费资源，太高会&lt;strong&gt;造成拥堵&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>数据结构</title>
        <link>https://deathofbrain.github.io/p/structure-key-points/</link>
        <pubDate>Tue, 24 Dec 2024 00:00:00 +0000</pubDate>
        
        <guid>https://deathofbrain.github.io/p/structure-key-points/</guid>
        <description>&lt;h2 id=&#34;绪论&#34;&gt;绪论
&lt;/h2&gt;&lt;h3 id=&#34;数据结构的基本概念&#34;&gt;数据结构的基本概念
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;逻辑结构&lt;/p&gt;
&lt;p&gt;逻辑结构是指数据对象中&lt;strong&gt;数据元素之间的相互关系&lt;/strong&gt;，即从&lt;strong&gt;逻辑上&lt;/strong&gt;描述数据元素之间的关系。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意与存储结构之间做区分&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;逻辑结构分为&lt;strong&gt;线性结构&lt;/strong&gt;和&lt;strong&gt;非线性结构&lt;/strong&gt;，再细分为&lt;strong&gt;集合结构&lt;/strong&gt;、&lt;strong&gt;线性结构&lt;/strong&gt;、&lt;strong&gt;树形结构&lt;/strong&gt;和&lt;strong&gt;图形结构&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;基本上是判断一个数据结构是属于哪种逻辑结构，所以心中有数就好。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;存储结构&lt;/p&gt;
&lt;p&gt;存储结构则是指数据对象中数据元素之间的&lt;strong&gt;存储关系&lt;/strong&gt;，即从&lt;strong&gt;物理上&lt;/strong&gt;描述数据元素之间的关系。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;逻辑结构是你看到的，存储结构是计算机看到的。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;存储结构分为&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;顺序存储结构&lt;/strong&gt;：逻辑上相邻的元素在物理上也相邻&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;链式存储结构&lt;/strong&gt;：逻辑上相邻的元素在物理上不一定相邻&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;索引存储结构&lt;/strong&gt;：在存储结构中增加附加的索引表&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;散列存储结构&lt;/strong&gt;：根据关键字直接计算出存储地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据的运算
数据的运算是指对数据对象进行的操作，包括&lt;strong&gt;运算的定义&lt;/strong&gt;和&lt;strong&gt;运算的实现&lt;/strong&gt;两个方面。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：运算的定义是针对逻辑结构的（如树的遍历等），运算的实现是针对存储结构的（对树的遍历来说，顺序存储和链式存储算法实现一定不同）。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;数据的逻辑结构独立于存储结构&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图的邻接表和邻接矩阵都可以表示图这种逻辑结构。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在存储数据时，不仅要存储数据元素本身，还要存储数据元素之间的逻辑关系。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;时间复杂度和空间复杂度-&#34;&gt;时间复杂度和空间复杂度 (⭐)
&lt;/h3&gt;&lt;p&gt;每年必考，常见于选择题第一题和算法题第三小问。其中算法题主要是去研究&lt;strong&gt;你写的&lt;/strong&gt;算法的时空复杂度，选择题则是考察&lt;strong&gt;一段代码&lt;/strong&gt;的时空复杂度。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;时空复杂度的加法规则和乘法规则&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;加法规则：$T(n) = O(max(f(n),g(n)))$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;两个算法串行执行时，时间复杂度取最大值&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;func1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Hello World&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// O(n)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Hello World&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// O(n^2)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// func的时间复杂度为O(n^2)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;乘法规则：$T(n) = O(f(n) \times g(n))$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;两个算法嵌套执行时，时间复杂度相乘&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;func2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// O(n)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;func1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// O(n^2)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// O(n) * O(n^2) = O(n^3)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// func2的时间复杂度为O(n^3)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算时间复杂度的通用办法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单层嵌套&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;待续……&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
    </channel>
</rss>
